# Chapter 5.3: Reusable Join Library

*Purpose: Build a comprehensive library of tested SQL join patterns that solve common Epic EHI analysis challenges, from simple patient context queries to complex multi-domain relationships.*

### Why You Need a Join Library

Epic's data spans hundreds of tables with intricate relationships. Without a systematic approach to joins, you'll find yourself:
- Writing the same complex joins repeatedly
- Making subtle errors in composite key relationships
- Missing important data due to incorrect join types
- Suffering from poor query performance

This chapter provides battle-tested join patterns you can use immediately, adapt for your needs, and build upon as you explore your data.

### The Foundation: Patient Context Join

Let's start with the most fundamental join pattern - getting complete patient context. This forms the basis for almost every analysis you'll perform.

<example-query description="Complete patient context with demographics">
-- Basic patient information with their most recent encounter
WITH patient_context AS (
  SELECT 
    p.PAT_ID,
    p.PAT_NAME,
    p.BIRTH_DATE,
    p.EMAIL_ADDRESS,
    p.HOME_PHONE,
    -- Calculate age at time of query
    CAST((julianday('now') - julianday(p.BIRTH_DATE)) / 365.25 AS INTEGER) as age_years,
    p.STATE_C_NAME as state,
    p.CITY,
    p.ZIP,
    -- Get most recent encounter info
    MAX(pe.CONTACT_DATE) as last_visit_date,
    COUNT(DISTINCT pe.PAT_ENC_CSN_ID) as total_visits
  FROM PATIENT p
  LEFT JOIN PAT_ENC pe ON p.PAT_ID = pe.PAT_ID
  GROUP BY p.PAT_ID, p.PAT_NAME, p.BIRTH_DATE, 
           p.EMAIL_ADDRESS, p.HOME_PHONE,
           p.STATE_C_NAME, p.CITY, p.ZIP
)
SELECT * FROM patient_context;
</example-query>

**Key Pattern Elements:**
- Use `LEFT JOIN` to include patients without encounters
- Group by all non-aggregated columns
- Calculate derived fields (age) in the query
- Use CTEs for readability

### Encounter-Centric Joins

The **Contact Serial Number (CSN)** is your key to linking clinical events. Here's how to build a complete encounter view:

<example-query description="Complete encounter details with provider and department">
SELECT 
  pe.PAT_ENC_CSN_ID,
  pe.CONTACT_DATE,
  pe.APPT_STATUS_C_NAME as appointment_status,
  pe.FIN_CLASS_C_NAME as financial_class,
  -- Patient info
  p.PAT_NAME,
  p.PAT_ID,
  -- Provider info
  pe.VISIT_PROV_ID,
  ser.PROV_NAME as visit_provider_name,
  -- Department info
  pe.DEPARTMENT_ID,
  dep.DEPARTMENT_NAME,
  -- Hospital account linkage
  pe.HSP_ACCOUNT_ID,
  -- Admission/discharge for hospital encounters
  pe.HOSP_ADMSN_TIME as admission_time,
  pe.HOSP_DISCHRG_TIME as discharge_time
FROM PAT_ENC pe
INNER JOIN PATIENT p ON pe.PAT_ID = p.PAT_ID
LEFT JOIN CLARITY_SER ser ON pe.VISIT_PROV_ID = ser.PROV_ID
LEFT JOIN CLARITY_DEP dep ON pe.DEPARTMENT_ID = dep.DEPARTMENT_ID
WHERE pe.CONTACT_DATE >= '2018-01-01'
ORDER BY pe.CONTACT_DATE DESC
LIMIT 10;
</example-query>

**Pattern Insights:**
- `INNER JOIN` to PATIENT ensures valid patient records
- `LEFT JOIN` to provider/department handles missing data
- Include both IDs and names for debugging
- Always filter by date for performance

### The LINE Pattern in Action

Epic uses the **LINE** pattern extensively for one-to-many relationships. Here's how to work with diagnoses:

<example-query description="Encounters with all diagnoses using LINE pattern">
SELECT 
  pe.PAT_ENC_CSN_ID,
  pe.CONTACT_DATE,
  pe.APPT_STATUS_C_NAME as visit_type,
  -- Diagnosis information with LINE
  dx.LINE as diagnosis_sequence,
  CASE 
    WHEN dx.LINE = 1 THEN 'Primary'
    WHEN dx.LINE = 2 THEN 'Secondary'
    ELSE 'Additional'
  END as diagnosis_rank,
  dx.DX_ID,
  edg.DX_NAME,
  -- Patient context
  p.PAT_NAME
FROM PAT_ENC pe
INNER JOIN PATIENT p ON pe.PAT_ID = p.PAT_ID
INNER JOIN PAT_ENC_DX dx ON pe.PAT_ENC_CSN_ID = dx.PAT_ENC_CSN_ID
LEFT JOIN CLARITY_EDG edg ON dx.DX_ID = edg.DX_ID
WHERE pe.CONTACT_DATE BETWEEN '2018-01-01' AND '2018-12-31'
  AND pe.APPT_STATUS_C_NAME = 'Completed'
ORDER BY pe.PAT_ENC_CSN_ID, dx.LINE;
</example-query>

**LINE Pattern Rules:**
- Always include LINE in your ORDER BY
- Don't assume LINE values are sequential
- LINE typically starts at 1 (not 0)
- Use CASE statements to interpret LINE meaning

### Complex Multi-Table Joins

Sometimes you need to traverse multiple relationships. Here's a pattern for linking patients to their orders and results:

<example-query description="Patient orders with results - multi-hop join">
WITH order_summary AS (
  SELECT 
    op.PAT_ID,
    op.PAT_ENC_CSN_ID,
    op.ORDER_PROC_ID,
    op.ORDER_TYPE_C_NAME as order_type,
    op.DESCRIPTION as procedure_name,
    op.ORDER_TIME,
    op.RESULT_TIME,
    -- Count components per order
    COUNT(DISTINCT res.COMPONENT_ID) as result_components,
    -- Check for any abnormal flags
    MAX(CASE 
      WHEN res.RESULT_FLAG_C_NAME IN ('High', 'Low', 'Abnormal') 
      THEN 1 ELSE 0 
    END) as has_abnormal_results
  FROM ORDER_PROC op
  LEFT JOIN ORDER_RESULTS res ON op.ORDER_PROC_ID = res.ORDER_PROC_ID
  GROUP BY op.PAT_ID, op.PAT_ENC_CSN_ID, op.ORDER_PROC_ID,
           op.ORDER_TYPE_C_NAME, op.DESCRIPTION, 
           op.ORDER_TIME, op.RESULT_TIME
)
SELECT 
  p.PAT_NAME,
  pe.CONTACT_DATE,
  os.procedure_name,
  os.ORDER_TIME,
  os.RESULT_TIME,
  -- Calculate turnaround time in hours
  ROUND((julianday(os.RESULT_TIME) - julianday(os.ORDER_TIME)) * 24, 1) as turnaround_hours,
  os.result_components,
  CASE 
    WHEN os.has_abnormal_results = 1 THEN 'Yes' 
    ELSE 'No' 
  END as abnormal_flag
FROM order_summary os
INNER JOIN PATIENT p ON os.PAT_ID = p.PAT_ID
INNER JOIN PAT_ENC pe ON os.PAT_ENC_CSN_ID = pe.PAT_ENC_CSN_ID
WHERE os.order_type = 'Lab'
  AND os.RESULT_TIME IS NOT NULL
ORDER BY os.ORDER_TIME DESC
LIMIT 20;
</example-query>

**Multi-Join Best Practices:**
- Use CTEs to break complex logic into steps
- Aggregate early to avoid cartesian products
- Calculate metrics (turnaround time) in the query
- Filter aggressively to improve performance

### Coverage and Insurance Joins

Insurance relationships require careful handling due to filing order and effective dates:

<example-query description="Patient coverage information with payor details">
SELECT 
  p.PAT_ID,
  p.PAT_NAME,
  -- Coverage details
  c.COVERAGE_ID,
  c.PAYOR_ID,
  c.PAYOR_ID_PAYOR_NAME as payor_name,
  c.PLAN_ID_BENEFIT_PLAN_NAME as plan_name,
  -- Coverage dates
  c.CVG_EFF_DT as effective_date,
  c.CVG_TERM_DT as termination_date,
  -- Check if currently active
  CASE 
    WHEN c.CVG_EFF_DT <= date('now') 
     AND (c.CVG_TERM_DT IS NULL OR c.CVG_TERM_DT >= date('now'))
    THEN 'Active'
    ELSE 'Inactive'
  END as coverage_status
FROM PATIENT p
-- Get all coverage records for filing order analysis
LEFT JOIN PAT_CVG_FILE_ORDER pcfo ON p.PAT_ID = pcfo.PAT_ID
LEFT JOIN COVERAGE c ON pcfo.COVERAGE_ID = c.COVERAGE_ID
WHERE p.PAT_ID IS NOT NULL
ORDER BY p.PAT_ID, pcfo.FILING_ORDER;
</example-query>

### Performance-Optimized Join Patterns

For large datasets, consider these optimization strategies:

<example-query description="Optimized pattern using date filters and limited columns">
-- Pattern: Filter early, select only needed columns
WITH recent_encounters AS (
  -- Step 1: Narrow down to relevant encounters first
  SELECT 
    PAT_ID,
    PAT_ENC_CSN_ID,
    CONTACT_DATE,
    DEPARTMENT_ID
  FROM PAT_ENC
  WHERE CONTACT_DATE >= date('now', '-90 days')
    AND APPT_STATUS_C_NAME = 'Completed'
),
encounter_diagnoses AS (
  -- Step 2: Get diagnoses only for filtered encounters
  SELECT 
    re.PAT_ID,
    re.PAT_ENC_CSN_ID,
    re.CONTACT_DATE,
    dx.LINE,
    edg.DX_NAME
  FROM recent_encounters re
  INNER JOIN PAT_ENC_DX dx ON re.PAT_ENC_CSN_ID = dx.PAT_ENC_CSN_ID
  LEFT JOIN CLARITY_EDG edg ON dx.DX_ID = edg.DX_ID
  WHERE dx.LINE <= 3  -- Only first 3 diagnoses
)
-- Step 3: Final join for display
SELECT 
  p.PAT_NAME,
  ed.CONTACT_DATE,
  GROUP_CONCAT(ed.DX_NAME, '; ') as diagnoses
FROM encounter_diagnoses ed
INNER JOIN PATIENT p ON ed.PAT_ID = p.PAT_ID
GROUP BY p.PAT_NAME, ed.CONTACT_DATE
ORDER BY ed.CONTACT_DATE DESC;
</example-query>

**Optimization Principles:**
1. **Filter Early**: Apply WHERE clauses before joins
2. **Select Sparingly**: Only include needed columns
3. **Use CTEs**: Break complex queries into logical steps
4. **Limit Results**: Use TOP/LIMIT during development
5. **Index Awareness**: Join on indexed columns (IDs)

### Handling Missing Data with Outer Joins

Epic data often has gaps. Here's how to handle them gracefully:

<example-query description="Find patients without recent encounters">
-- Pattern: Use LEFT JOIN to find missing relationships
SELECT 
  p.PAT_ID,
  p.PAT_NAME,
  p.BIRTH_DATE,
  -- Last encounter info (may be NULL)
  MAX(pe.CONTACT_DATE) as last_encounter_date,
  -- Calculate days since last visit
  CASE 
    WHEN MAX(pe.CONTACT_DATE) IS NULL THEN 'Never'
    ELSE CAST(julianday('now') - julianday(MAX(pe.CONTACT_DATE)) AS INTEGER) || ' days ago'
  END as last_visit_info,
  -- Count total encounters
  COUNT(pe.PAT_ENC_CSN_ID) as total_encounters
FROM PATIENT p
LEFT JOIN PAT_ENC pe ON p.PAT_ID = pe.PAT_ID
WHERE p.BIRTH_DATE < date('now', '-18 years')  -- Adults only
GROUP BY p.PAT_ID, p.PAT_NAME, p.BIRTH_DATE
HAVING COUNT(pe.PAT_ENC_CSN_ID) = 0  -- No encounters
    OR MAX(pe.CONTACT_DATE) < date('now', '-365 days')  -- Or no recent visits
ORDER BY total_encounters, last_encounter_date;
</example-query>

### Building Reusable Views

For frequently used join patterns, create views:

<example-query description="Create a reusable patient summary view">
-- Note: This is a conceptual example - creating views requires appropriate permissions
-- Save this pattern as a CTE in your queries instead

WITH v_patient_summary AS (
  SELECT 
    p.PAT_ID,
    p.PAT_NAME,
    p.BIRTH_DATE,
    CAST((julianday('now') - julianday(p.BIRTH_DATE)) / 365.25 AS INTEGER) as age,
    p.STATE_C_NAME as state,
    -- Encounter metrics
    COUNT(DISTINCT pe.PAT_ENC_CSN_ID) as total_encounters,
    COUNT(DISTINCT CASE 
      WHEN pe.CONTACT_DATE >= date('now', '-365 days') 
      THEN pe.PAT_ENC_CSN_ID 
    END) as encounters_past_year,
    MAX(pe.CONTACT_DATE) as last_encounter_date,
    -- Order metrics  
    COUNT(DISTINCT op.ORDER_PROC_ID) as total_orders
  FROM PATIENT p
  LEFT JOIN PAT_ENC pe ON p.PAT_ID = pe.PAT_ID
  LEFT JOIN ORDER_PROC op ON p.PAT_ID = op.PAT_ID
  GROUP BY p.PAT_ID, p.PAT_NAME, p.BIRTH_DATE, p.STATE_C_NAME
)
SELECT * FROM v_patient_summary
WHERE encounters_past_year > 0
ORDER BY total_encounters DESC
LIMIT 10;
</example-query>

### Common Join Pitfalls and Solutions

#### Pitfall 1: Forgetting Composite Keys
```sql
-- WRONG: Missing LINE in join
SELECT * FROM PAT_ENC pe
JOIN PAT_ENC_DX dx ON pe.PAT_ENC_CSN_ID = dx.PAT_ENC_CSN_ID
-- This works but might miss relationships that use LINE

-- CORRECT: Include all key components
SELECT * FROM PAT_ENC pe
JOIN PAT_ENC_DX dx ON pe.PAT_ENC_CSN_ID = dx.PAT_ENC_CSN_ID
-- LINE is handled separately in Epic EHI exports
```

#### Pitfall 2: Cartesian Products
```sql
-- WRONG: Creates massive result set
SELECT * FROM PATIENT p, PAT_ENC pe, ORDER_PROC op

-- CORRECT: Explicit joins with conditions
SELECT * FROM PATIENT p
INNER JOIN PAT_ENC pe ON p.PAT_ID = pe.PAT_ID
INNER JOIN ORDER_PROC op ON pe.PAT_ENC_CSN_ID = op.PAT_ENC_CSN_ID
```

#### Pitfall 3: Not Handling NULLs
```sql
-- Account for potential NULL values in outer joins
SELECT 
  p.PAT_NAME,
  COALESCE(pe.CONTACT_DATE, 'No visits') as last_visit,
  COALESCE(dep.DEPARTMENT_NAME, 'Unknown Dept') as department
FROM PATIENT p
LEFT JOIN PAT_ENC pe ON p.PAT_ID = pe.PAT_ID
LEFT JOIN CLARITY_DEP dep ON pe.DEPARTMENT_ID = dep.DEPARTMENT_ID
```

### Query Templates for Common Scenarios

#### Template 1: Patient Longitudinal View
<example-query description="Track patient journey over time">
-- Longitudinal patient view showing encounter timeline
SELECT 
  p.PAT_NAME,
  pe.CONTACT_DATE,
  pe.APPT_STATUS_C_NAME as visit_type,
  dep.DEPARTMENT_NAME,
  -- Create narrative of visit
  pe.CONTACT_DATE || ': ' || 
  COALESCE(pe.APPT_STATUS_C_NAME, 'Unknown') || ' at ' || 
  COALESCE(dep.DEPARTMENT_NAME, 'Unknown Dept') as visit_narrative
FROM PATIENT p
INNER JOIN PAT_ENC pe ON p.PAT_ID = pe.PAT_ID
LEFT JOIN CLARITY_DEP dep ON pe.DEPARTMENT_ID = dep.DEPARTMENT_ID
WHERE p.PAT_ID = 'Z7004242'  -- Replace with target patient
ORDER BY pe.CONTACT_DATE DESC;
</example-query>

#### Template 2: Department Activity Analysis
<example-query description="Analyze department utilization patterns">
-- Department utilization analysis
SELECT 
  dep.DEPARTMENT_NAME,
  COUNT(DISTINCT pe.PAT_ENC_CSN_ID) as total_encounters,
  COUNT(DISTINCT pe.PAT_ID) as unique_patients,
  COUNT(DISTINCT DATE(pe.CONTACT_DATE)) as days_with_visits,
  -- Calculate average daily volume
  ROUND(
    CAST(COUNT(DISTINCT pe.PAT_ENC_CSN_ID) AS FLOAT) / 
    COUNT(DISTINCT DATE(pe.CONTACT_DATE)), 
    1
  ) as avg_daily_encounters
FROM CLARITY_DEP dep
INNER JOIN PAT_ENC pe ON dep.DEPARTMENT_ID = pe.DEPARTMENT_ID
WHERE pe.CONTACT_DATE >= date('now', '-90 days')
  AND pe.APPT_STATUS_C_NAME = 'Completed'
GROUP BY dep.DEPARTMENT_NAME
HAVING COUNT(DISTINCT pe.PAT_ENC_CSN_ID) > 5  -- Active departments only
ORDER BY total_encounters DESC;
</example-query>

---

### Key Takeaways

1. **Master the Core Relationships**: PAT_ID links patients, CSN links encounters, ORDER_PROC_ID links orders
2. **Embrace the LINE Pattern**: It's everywhere in Epic - learn to work with it, not against it
3. **Use CTEs Liberally**: They make complex queries readable and debuggable
4. **Filter Early and Often**: Apply WHERE clauses before joins for better performance
5. **Handle NULLs Gracefully**: Epic data has gaps - use LEFT JOINs and COALESCE
6. **Think in Patterns**: Most Epic joins follow predictable patterns - learn them once, apply everywhere
7. **Test with Small Data**: Validate your joins on limited data before running on full datasets

Remember: these patterns are starting points. Every Epic implementation has variations, so always verify relationships in your specific dataset before relying on them for analysis or reporting.