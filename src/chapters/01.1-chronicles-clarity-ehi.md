# Chapter 1.1: Chronicles → Clarity → EHI

*Purpose: To understand Epic's three-tier data architecture and why your export is structured the way it is.*

### The Three Layers That Shape Your Data

When you open your Epic EHI export, you're looking at the end result of a fascinating architectural journey. The cryptic table names, the mysterious LINE columns, and the one-day lag all trace back to Epic's three-tier architecture: **Chronicles** → **Clarity** → **EHI Export**.

Understanding this flow isn't academic—it directly impacts how you query the data, what patterns you'll find, and why certain limitations exist. Let's trace your data's journey from a doctor's click to your TSV file.

### Chronicles: The Living, Breathing Database

**Chronicles** is Epic's operational database—the real-time engine powering every hospital and clinic using Epic. Built on InterSystems Caché (formerly MUMPS), it's a hierarchical database optimized for one thing: keeping patients alive and workflows moving.

Think of Chronicles as a massive tree structure. When a doctor orders medication, the data might be stored like this:

```
^PAT(12345,"MED",1) = "Aspirin|81mg|Daily"
^PAT(12345,"MED",2) = "Lisinopril|10mg|Daily"
^PAT(12345,"ENC",99887,"DX",1) = "I10^Essential hypertension"
```

This hierarchical structure is perfect for clinical workflows. Need all medications for patient 12345? One lookup. Need all diagnoses for encounter 99887? Another direct path through the tree.

**Key characteristics:**
- **Technology**: InterSystems Caché/IRIS (hierarchical, object-oriented)
- **Performance**: Handles 1.8 billion database accesses per second across all Epic customers
- **Response time**: Sub-second for clinical operations
- **Structure**: Tree-like with multi-value arrays
- **Users**: Doctors, nurses, pharmacists—anyone providing care

### Clarity: The SQL Translation Layer

Here's the problem: While hierarchical databases are fantastic for clinical operations, they're terrible for reporting. Try writing a SQL JOIN against a tree structure—it doesn't work.

Enter **Clarity**: Epic's SQL-based reporting mirror. Every night, a massive ETL (Extract, Transform, Load) process converts the hierarchical Chronicles data into relational tables that tools like Crystal Reports, Tableau, or your Python scripts can understand.

<example-query description="See how Chronicles' multi-value arrays become Clarity rows with LINE numbers">
-- The LINE pattern exists because Chronicles stores multiple values in arrays
-- Each array position becomes a row with a LINE number in Clarity
SELECT 
  PAT_ENC_CSN_ID,
  LINE,
  DX_ID,
  PRIMARY_DX_YN
FROM PAT_ENC_DX
WHERE PAT_ENC_CSN_ID = '131163933'
ORDER BY LINE;
</example-query>

Notice the `LINE` column? That's Chronicles' array index preserved in SQL. When Chronicles stores `^ENC(131163933,"DX",1)` through `^ENC(131163933,"DX",3)`, Clarity creates three rows with LINE = 1, 2, and 3.

**Key characteristics:**
- **Technology**: Oracle or SQL Server (relational)
- **Update frequency**: Nightly ETL, typically 11 PM - 3 AM
- **Table count**: 18,000+ possible tables
- **Structure**: Traditional relational with foreign keys
- **Users**: Analysts, researchers, report writers

### The Nightly ETL: Where Magic (and Lag) Happens

The transformation from Chronicles to Clarity is a marvel of engineering that runs every night:

1. **11:00 PM**: ETL process begins
2. **11:00 PM - 3:00 AM**: Data extraction and transformation
   - Hierarchical structures → relational tables
   - Multi-value arrays → rows with LINE numbers
   - Internal IDs → human-readable names (where configured)
3. **3:00 AM**: Clarity updated with yesterday's finalized data
4. **Monday special**: Processes entire weekend (no ETL on Sunday)

<example-query description="Check the data freshness in your export">
-- Your data is always at least one day old due to the ETL process
SELECT 
  MAX(CONTACT_DATE) as most_recent_encounter,
  DATE('now') as today,
  JULIANDAY('now') - JULIANDAY(MAX(CONTACT_DATE)) as days_old
FROM PAT_ENC
WHERE CONTACT_DATE IS NOT NULL;
</example-query>

This ETL process creates the famous "one-day lag." If a patient visits the emergency room at 2 PM today, that encounter won't appear in Clarity (or your export) until tomorrow morning at the earliest.

### EHI Export: Your Point-in-Time Snapshot

The **EHI Export** is simply a snapshot of Clarity tables at a specific moment. When someone runs the export process, Epic:

1. Queries the specified Clarity tables
2. Applies any requested filters (date ranges, departments, etc.)
3. Outputs the data as tab-separated value (TSV) files
4. Includes only tables permitted by regulations and your organization's configuration

<example-query description="Explore what's included in your export">
-- Your export contains a subset of Clarity's 18,000+ tables
SELECT 
  COUNT(DISTINCT name) as table_count,
  SUM(CASE WHEN name LIKE '%HX' THEN 1 ELSE 0 END) as history_tables,
  SUM(CASE WHEN name LIKE 'V_%' THEN 1 ELSE 0 END) as view_tables,
  SUM(CASE WHEN name LIKE 'ZC_%' THEN 1 ELSE 0 END) as category_tables
FROM sqlite_master 
WHERE type = 'table';
</example-query>

### Why This Architecture Exists

You might wonder: why not just query Chronicles directly? Or skip Clarity and export straight from the source? The three-tier architecture exists for excellent reasons:

**1. Performance Isolation**
```
Patient Care (Chronicles)     Analytics (Clarity)
├─ Must be real-time          ├─ Can wait until tomorrow
├─ Simple queries only        ├─ Complex JOINs welcome
└─ Zero tolerance for lag     └─ Handles massive reports
```

**2. Technology Optimization**
- **Hierarchical** (Chronicles): Perfect for "get all data for this patient"
- **Relational** (Clarity): Perfect for "count all patients with diabetes who missed appointments"

**3. Historical Evolution**
- **1979**: Epic founded, builds on MUMPS/hierarchical database
- **1990s**: SQL becomes the standard, but can't match MUMPS for healthcare workflows
- **Solution**: Keep both! MUMPS for operations, SQL for reporting

### Working With the Consequences

Understanding this architecture helps explain many quirks in your data:

<example-query description="See how multi-value fields create composite keys">
-- Many tables use (ID, LINE) as a composite primary key
-- This pattern comes directly from Chronicles' array storage
SELECT 
  'PAT_ENC_DX' as table_name,
  COUNT(*) as total_rows,
  COUNT(DISTINCT PAT_ENC_CSN_ID) as unique_encounters,
  ROUND(CAST(COUNT(*) AS FLOAT) / COUNT(DISTINCT PAT_ENC_CSN_ID), 2) as avg_dx_per_encounter
FROM PAT_ENC_DX

UNION ALL

SELECT 
  'PAT_MEDICATIONS' as table_name,
  COUNT(*) as total_rows,
  COUNT(DISTINCT PAT_ID) as unique_patients,
  ROUND(CAST(COUNT(*) AS FLOAT) / COUNT(DISTINCT PAT_ID), 2) as avg_meds_per_patient
FROM PAT_MEDICATIONS;
</example-query>

**The Good:**
- Proven scalability (handles Kaiser Permanente's 12.5 million members)
- Clinical safety (reporting never impacts patient care)
- Rich audit trails (history tables track every change)

**The Challenging:**
- One-day minimum lag for all data
- Complex patterns like (ID, LINE) keys everywhere
- No real-time updates or streaming

### Architecture Decision Records

Epic's architects made deliberate choices that cascade through your data:

**ADR-1: Keep Clinical Operations Fast**
- **Decision**: Use hierarchical database for patient care
- **Consequence**: Your data needs transformation to be queryable

**ADR-2: Support Industry-Standard Reporting**
- **Decision**: Add SQL-based Clarity layer
- **Consequence**: Nightly ETL creates the one-day lag

**ADR-3: Never Let Reporting Impact Patient Care**
- **Decision**: Complete separation between Chronicles and Clarity
- **Consequence**: No real-time data in exports

**ADR-4: Preserve Array Semantics**
- **Decision**: Convert arrays to rows with LINE numbers
- **Consequence**: Composite keys throughout your data

### Practical Implications for Your Queries

<example-query description="Work with the architecture, not against it">
-- Understanding the architecture helps you write better queries
-- Example: Finding all diagnoses for today won't work!
SELECT 
  DATE('now') as today,
  COUNT(*) as encounters_for_today
FROM PAT_ENC 
WHERE DATE(CONTACT_DATE) = DATE('now');
-- This will always return 0 due to the one-day lag
</example-query>

<example-query description="Instead, work with yesterday's data">
-- Reliable query that respects the architecture
SELECT 
  DATE('now', '-1 day') as yesterday,
  COUNT(*) as encounters_for_yesterday,
  ENC_TYPE_C_NAME,
  COUNT(*) as count_by_type
FROM PAT_ENC 
WHERE DATE(CONTACT_DATE) = DATE('now', '-1 day')
GROUP BY ENC_TYPE_C_NAME
ORDER BY count_by_type DESC;
</example-query>

---

### Key Takeaways

1. **Three distinct layers** each serve a specific purpose: Chronicles (clinical), Clarity (reporting), EHI (export)
2. **The one-day lag is architectural**, not a bug—it's the price of performance isolation
3. **LINE columns everywhere** reflect Chronicles' hierarchical array storage
4. **Your TSV files** are a point-in-time snapshot of Clarity, not Chronicles
5. **18,000+ possible tables** exist because Clarity mirrors Epic's vast functionality
6. **Understanding "why"** helps you work with the architecture, not against it
7. **Different use cases** require different data sources—know when you need real-time