# Chapter 1.2: Anatomy of an EHI Export

*Purpose: Master the structure and format of an Epic EHI export so you can navigate and process it confidently from day one.*

---

### The Export Package: What's in the Box?

When you first receive an Epic EHI export, you're looking at a directory that might contain hundreds or even thousands of files. Let's demystify this structure and understand exactly what you're working with.

<example-query description="Count the tables in our sample database">
-- In a real export, these would be TSV files
-- Our sample has 550 tables loaded into SQLite
SELECT COUNT(*) as total_tables 
FROM sqlite_master 
WHERE type='table';
</example-query>

A typical export directory looks like this:

```
epic-ehi-export/
├── documents/
│   ├── epic_ehi_data_dictionary.pdf    -- Your field reference
│   └── export_parameters.txt            -- What data was included
├── export_manifest.tsv                  -- Index of all tables
├── patient.tsv                          -- Core patient demographics
├── pat_enc.tsv                          -- Patient encounters
├── clarity_dep.tsv                      -- Department reference data
├── hsp_account.tsv                      -- Hospital billing accounts
├── arpb_transactions.tsv                -- Professional billing
├── ... (hundreds more .tsv files)
└── readme.txt                           -- Export-specific notes
```

The **export_manifest.tsv** is your roadmap. It tells you exactly what tables were included, how many rows each contains, and when they were exported. Think of it as the table of contents for your data.

---

### Why TSV? Epic's Format Decision

You might wonder why Epic chose Tab-Separated Values (TSV) over the more common CSV format. The answer lies in healthcare data itself:

<example-query description="See why commas are problematic in healthcare data">
-- Look at patient names and addresses - commas everywhere!
SELECT 
    PAT_NAME,
    CITY || ', ' || STATE_C_NAME as location
FROM PATIENT
WHERE PAT_NAME LIKE '%,%'
LIMIT 5;
</example-query>

Healthcare data is full of commas:
- Patient names: "Smith, John A."
- Addresses: "123 Main St, Suite 5"
- Clinical notes: "Patient reports pain, rated 7/10"
- Diagnoses: "Diabetes, Type 2"

Epic's TSV specification uses these rules:
- **Delimiter**: Tab character (`\t`)
- **Line Ending**: Unix-style (`\n`)  
- **Character Encoding**: UTF-8
- **Null Values**: Empty string (not "NULL")
- **Header Row**: Always present
- **Escape Character**: Backslash (`\`)

When Epic does need to include special characters, they escape them:
- `\t` → Tab character
- `\n` → Newline  
- `\\` → Literal backslash

---

### Table Naming Patterns: Your Navigation Guide

Epic table names follow predictable patterns based on their functional module. Once you recognize these patterns, finding the data you need becomes much easier.

<example-query description="Explore table naming patterns by prefix">
-- Count tables by their prefix to see module organization
SELECT 
    CASE 
        WHEN name LIKE 'PAT_%' THEN 'PAT_ (Patient)'
        WHEN name LIKE 'HSP_%' THEN 'HSP_ (Hospital Billing)'  
        WHEN name LIKE 'ARPB_%' THEN 'ARPB_ (Professional Billing)'
        WHEN name LIKE 'ORDER_%' THEN 'ORDER_ (Clinical Orders)'
        WHEN name LIKE 'CLARITY_%' THEN 'CLARITY_ (Reference Data)'
        WHEN name LIKE 'ZC_%' THEN 'ZC_ (Category Values)'
        WHEN name LIKE '%_HX' THEN '*_HX (History Tables)'
        ELSE 'Other'
    END as table_type,
    COUNT(*) as table_count
FROM sqlite_master 
WHERE type = 'table'
GROUP BY table_type
ORDER BY table_count DESC;
</example-query>

Key prefixes to remember:

| Prefix | Module | Contains |
|--------|---------|----------|
| `PAT_` | Patient | Demographics, encounters, allergies |
| `HSP_` | Hospital Billing | Facility charges, accounts |
| `ARPB_` | Professional Billing | Physician charges |
| `ORDER_` | Orders | Labs, medications, procedures |
| `CLARITY_` | Reference | Providers, departments, locations |
| `ZC_` | Categories | Coded reference values |

Special suffixes indicate table variants:
- `_HX`: History tables tracking changes over time
- `_2`, `_3`, `_4`: Overflow tables for additional columns
- `_INFO`: Detailed information tables

<example-query description="Find all history tables in the database">
-- History tables track changes over time
SELECT name as history_table
FROM sqlite_master
WHERE type = 'table' 
  AND name LIKE '%_HX'
ORDER BY name
LIMIT 10;
</example-query>

---

### Understanding Table Documentation

Instead of requiring an external data dictionary, this database is self-documenting. Using the `_metadata` table introduced in the previous chapter, you can query for documentation on any table or column.

<example-query description="View documentation for the department table">
-- Get the description for the CLARITY_DEP table
SELECT documentation
FROM _metadata
WHERE table_name = 'CLARITY_DEP' AND column_name IS NULL;
</example-query>

<example-query description="View documentation for key columns in CLARITY_DEP">
-- Get descriptions for specific columns
SELECT column_name, documentation
FROM _metadata
WHERE table_name = 'CLARITY_DEP' 
  AND column_name IN ('DEPARTMENT_ID', 'DEPARTMENT_NAME', 'SPECIALTY_C_NAME');
</example-query>

This approach allows you to explore the schema and understand the data entirely within your SQL environment.

---

### File Size Patterns and Storage Planning

Export file sizes follow predictable patterns based on their content type:

<example-query description="Analyze data distribution across table types">
-- See which types of tables have the most data
-- Using PAT_ENC as a proxy for encounter volume
SELECT 
    'Core Patient Data' as category,
    COUNT(*) as row_count
FROM PATIENT
UNION ALL
SELECT 
    'Patient Encounters',
    COUNT(*) 
FROM PAT_ENC
UNION ALL
SELECT 
    'Professional Billing',
    COUNT(*)
FROM ARPB_TRANSACTIONS
UNION ALL
SELECT 
    'Reference Data (Departments)',
    COUNT(*)
FROM CLARITY_DEP;
</example-query>

Typical size distribution:
- **Tiny (<1MB)**: Reference tables like `ZC_*` categories
- **Small (1-10MB)**: Patient demographics, provider lists
- **Medium (10-100MB)**: Encounters, diagnoses, medications
- **Large (100MB-1GB)**: Transaction details, clinical notes
- **Huge (>1GB)**: Historical billing transactions

For storage planning:
```
TSV files size: X GB
After loading to database: ~2.5X GB
With indexes for performance: ~3.5X GB
Working space for analysis: ~5X GB
```

---

### Handling Split Files

When tables exceed 2GB or contain millions of rows, Epic splits them into multiple files:

```
arpb_transactions_001.tsv
arpb_transactions_002.tsv  
arpb_transactions_003.tsv
```

These files have identical headers and should be concatenated during import. The split is purely for file size management—the data is not partitioned by any business logic.

---

### The Export Manifest: Your Data Inventory

While our sample database doesn't include the manifest as a table, in a real export, the `export_manifest.tsv` provides crucial metadata:

```
TABLE_NAME          ROW_COUNT    FILE_SIZE_MB    EXPORT_DATETIME
PATIENT             50,000       12.5            2024-01-15 03:45:00
PAT_ENC             840,000      234.8           2024-01-15 03:47:00  
HSP_TRANSACTIONS    2,500,000    890.2           2024-01-15 04:15:00
```

Use the manifest to:
- Verify completeness of your export
- Estimate processing time and resources
- Identify the largest tables requiring special handling
- Confirm the export date/time for all tables

---

### Common Gotchas and Solutions

**Empty Tables**: Don't panic if you find empty tables. This usually means:
- The module isn't used at the organization
- Data was filtered out for privacy/security
- Export parameters excluded certain data types

**Character Encoding Issues**: If you see garbled text:
1. Verify UTF-8 encoding: `file -i patient.tsv`
2. Try UTF-8 with BOM: `utf-8-sig` in Python
3. Check for Windows line endings: `dos2unix *.tsv`

**Missing Relationships**: Unlike a traditional database export, TSV files don't include:
- Primary key definitions
- Foreign key constraints  
- Indexes
- Stored procedures

You'll need to recreate these based on the documentation.

---

### Your Pre-Flight Checklist

Before diving into analysis, verify your export:

<example-query description="Run a basic health check on the data">
-- Check that core tables exist and have data
SELECT 
    'PATIENT' as table_name,
    CASE WHEN COUNT(*) > 0 THEN 'OK (' || COUNT(*) || ' rows)' 
         ELSE 'EMPTY' END as status
FROM PATIENT
UNION ALL
SELECT 
    'PAT_ENC',
    CASE WHEN COUNT(*) > 0 THEN 'OK (' || COUNT(*) || ' rows)' 
         ELSE 'EMPTY' END
FROM PAT_ENC
UNION ALL
SELECT 
    'CLARITY_DEP',
    CASE WHEN COUNT(*) > 0 THEN 'OK (' || COUNT(*) || ' rows)' 
         ELSE 'EMPTY' END
FROM CLARITY_DEP;
</example-query>

- [ ] Locate and review `export_manifest.tsv`
- [ ] Verify documentation matches your Epic version
- [ ] Check character encoding on sample files
- [ ] Calculate total storage requirements
- [ ] Test your TSV parser on a small file
- [ ] Note any split files that need concatenation
- [ ] Identify empty or missing tables

---

### Key Takeaways

1. **TSV format has good reasons**: Healthcare data is full of commas, making tabs a better delimiter
2. **File names follow predictable patterns**: Learn the prefixes and you can find any data domain
3. **Documentation is embedded**: Table and column descriptions are in the schema itself
4. **The manifest is your roadmap**: Always check it first to understand what you're working with
5. **Size matters**: Plan storage for 3-5x the raw file size after loading and indexing

With this foundation, you're ready to start loading and exploring your Epic EHI data. The structure might seem overwhelming at first, but remember: it's just a collection of related tables following consistent patterns. Master those patterns, and you master the data.