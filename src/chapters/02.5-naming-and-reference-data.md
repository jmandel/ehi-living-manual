# Chapter 2.5: Naming & Reference Data

*Purpose: Master Epic's systematic naming conventions to navigate 18,000+ tables and decode the ubiquitous _C/_C_NAME denormalization pattern.*

### Epic's Naming Philosophy

With over 18,000 potential tables in a full Epic installation, systematic naming isn't just helpful—it's essential. Epic's conventions evolved over four decades, creating a self-documenting system where table and column names reveal purpose, relationships, and data types.

**The Core Principle**: Names encode metadata. A table named `PAT_ENC_DX` immediately tells you:
- `PAT_` = Patient module
- `ENC` = Encounter-related
- `DX` = Diagnosis data

This isn't accidental. It's Epic's way of organizing complexity.

---

### Table Prefix Atlas

Epic organizes tables by functional module, with each prefix mapping to a specific domain:

<example-query description="Count tables by module prefix">
SELECT 
  SUBSTR(name, 1, INSTR(name || '_', '_') - 1) AS prefix,
  COUNT(*) as table_count
FROM sqlite_master 
WHERE type='table' 
  AND name NOT LIKE 'sqlite_%'
GROUP BY prefix
ORDER BY table_count DESC
LIMIT 15;
</example-query>

#### Major Module Prefixes

**Clinical Modules**:
- **PAT_** (68 tables): Core patient data—demographics, encounters, clinical documentation
- **ORDER_** (48 tables): All types of clinical orders—labs, medications, procedures
- **IP_** (13 tables): Inpatient-specific documentation like flowsheets
- **MED_** (11 tables): Medication administration and reconciliation

**Financial Modules**:
- **HSP_** (52 tables): Hospital billing—facility charges, accounts, transactions
- **ARPB_** (15 tables): Professional billing—physician charges and payments
- **COVERAGE_** (7 tables): Insurance coverage and benefits

**Reference & Configuration**:
- **CLARITY_** (28 tables): Master files for providers, departments, locations
- **CL_** (26 tables): Clinical and claims configuration

**Patient Engagement**:
- **MYC_** (16 tables): MyChart patient portal interactions

<example-query description="Find all patient-related tables">
-- Find tables with 'PATIENT' or 'PAT_' prefix using the metadata
SELECT DISTINCT table_name
FROM _metadata
WHERE table_name LIKE 'PAT_%' OR table_name LIKE 'PATIENT%'
ORDER BY table_name
LIMIT 10;
</example-query>

---

### The _C / _C_NAME Pattern

Epic's most distinctive pattern is the **denormalized category** system. Instead of joining to reference tables, Epic stores both the code and its description:

<example-query description="See the _C_NAME pattern in action">
SELECT 
  APPT_STATUS_C_NAME,
  COUNT(*) as frequency
FROM PAT_ENC
WHERE APPT_STATUS_C_NAME IS NOT NULL
GROUP BY APPT_STATUS_C_NAME
ORDER BY frequency DESC;
</example-query>

#### Why This Pattern Exists

In a traditional database, you'd have:
```sql
-- Traditional approach (NOT Epic's way)
PAT_ENC.STATUS_C → ZC_STATUS.STATUS_C → ZC_STATUS.NAME
```

Epic's approach:
```sql
-- Epic's denormalized approach
PAT_ENC.STATUS_C      -- The code (if included)
PAT_ENC.STATUS_C_NAME -- The human-readable value
```

**Benefits**:
- **Performance**: No joins needed for reports
- **Simplicity**: One table contains everything
- **Consistency**: Values frozen at transaction time

**Trade-offs**:
- **Storage**: Same text repeated millions of times
- **Updates**: Category name changes don't propagate
- **Analysis**: Must extract distinct values yourself

---

### ZC_ Tables: The Missing Reference Data

In Chronicles (Epic's source database), **ZC_ tables** store category lists—the valid values for all those `_C` fields. These are Epic's master reference tables.

**The Problem**: EHI exports rarely include ZC_ tables. 

**The Solution**: Build your own reference tables from the denormalized data:

<example-query description="Extract reference data from denormalized columns">
WITH category_values AS (
  SELECT DISTINCT
    'HOSP_ADMSN_TYPE' as category,
    HOSP_ADMSN_TYPE_C_NAME as value
  FROM PAT_ENC
  WHERE HOSP_ADMSN_TYPE_C_NAME IS NOT NULL
  
  UNION ALL
  
  SELECT DISTINCT
    'APPT_STATUS' as category,
    APPT_STATUS_C_NAME as value
  FROM PAT_ENC
  WHERE APPT_STATUS_C_NAME IS NOT NULL
)
SELECT 
  category,
  value,
  'Extracted from PAT_ENC' as source
FROM category_values
ORDER BY category, value;
</example-query>

---

### Column Naming Patterns

Epic uses consistent suffixes to indicate data type and purpose:

<example-query description="Analyze column naming patterns in PAT_ENC">
WITH column_patterns AS (
  SELECT column_name
  FROM (
    SELECT 'PAT_ID' as column_name UNION ALL
    SELECT 'PAT_ENC_CSN_ID' UNION ALL
    SELECT 'CONTACT_DATE' UNION ALL
    SELECT 'ENC_CLOSED_YN' UNION ALL
    SELECT 'PCP_PROV_ID' UNION ALL
    SELECT 'APPT_STATUS_C_NAME'
  )
)
SELECT 
  CASE
    WHEN column_name LIKE '%_ID' THEN 'Identifier'
    WHEN column_name LIKE '%_C_NAME' THEN 'Category Name'
    WHEN column_name LIKE '%_YN' THEN 'Yes/No Flag'
    WHEN column_name LIKE '%_DATE' THEN 'Date'
    WHEN column_name LIKE '%_DTTM' THEN 'DateTime'
    ELSE 'Other'
  END as pattern_type,
  column_name as example
FROM column_patterns
ORDER BY pattern_type;
</example-query>

#### Common Suffix Dictionary

| Suffix | Meaning | Example | Notes |
|--------|---------|---------|-------|
| `_ID` | Identifier | `PAT_ID`, `PROV_ID` | Usually VARCHAR, not numeric |
| `_C` | Category code | `STATUS_C` | Integer code (rarely in exports) |
| `_C_NAME` | Category name | `STATUS_C_NAME` | Human-readable value |
| `_YN` | Yes/No flag | `ACTIVE_YN` | Values: 'Y', 'N', or NULL |
| `_DATE` | Date only | `BIRTH_DATE` | No time component |
| `_DTTM` | Date and time | `ENTRY_DTTM` | Full timestamp |
| `_USER_ID` | User reference | `UPDATE_USER_ID` | Links to user (not in export) |
| `_AMT` | Amount | `CHARGE_AMT` | Monetary value |

---

### Special Table Types

#### History Tables (_HX Suffix)

History tables track changes over time using an insert-only pattern:

<example-query description="Find all history tables">
SELECT 
  name as history_table,
  REPLACE(name, '_HX', '') as parent_table
FROM sqlite_master 
WHERE type='table' 
  AND name LIKE '%_HX'
ORDER BY name
LIMIT 10;
</example-query>

Key characteristics:
- Never updated, only inserted
- Include `LINE` for multiple versions
- Contain user and timestamp fields

#### Overflow Tables (Numeric Suffixes)

When tables exceed Epic's column limit, they overflow into numbered tables:

<example-query description="Find overflow table patterns">
SELECT name as table_name
FROM sqlite_master 
WHERE type='table' 
  AND (name LIKE 'PATIENT_%' OR name = 'PATIENT')
  AND name GLOB '*[0-9]'
ORDER BY name;
</example-query>

Pattern:
- `PATIENT` - Core demographics
- `PATIENT_2` through `PATIENT_6` - Additional fields

#### View Tables (V_ Prefix)

Pre-joined or aggregated data for common queries:

<example-query description="List available view tables">
SELECT 
  name as view_table,
  CASE
    WHEN name LIKE '%BIL%' THEN 'Billing'
    WHEN name LIKE '%HNO%' THEN 'History'
    WHEN name LIKE '%HSB%' THEN 'Hospital'
    ELSE 'Other'
  END as category
FROM sqlite_master 
WHERE type='table' 
  AND name LIKE 'V_%'
ORDER BY name;
</example-query>

---

### Building Your Reference Catalog

Since EHI exports lack ZC_ tables, create your own reference catalog:

<example-query description="Build comprehensive reference catalog">
-- Extract all category values from PAT_ENC
WITH all_categories AS (
  -- Appointment Status
  SELECT DISTINCT 
    'Appointment Status' as category_type,
    APPT_STATUS_C_NAME as value,
    COUNT(*) as usage_count
  FROM PAT_ENC
  WHERE APPT_STATUS_C_NAME IS NOT NULL
  GROUP BY APPT_STATUS_C_NAME
  
  UNION ALL
  
  -- Hospital Admission Type  
  SELECT DISTINCT
    'Hospital Admission Type' as category_type,
    HOSP_ADMSN_TYPE_C_NAME as value,
    COUNT(*) as usage_count
  FROM PAT_ENC
  WHERE HOSP_ADMSN_TYPE_C_NAME IS NOT NULL
  GROUP BY HOSP_ADMSN_TYPE_C_NAME
  
  UNION ALL
  
  -- Consent Type
  SELECT DISTINCT
    'Consent Type' as category_type,
    CONSENT_TYPE_C_NAME as value,
    COUNT(*) as usage_count
  FROM PAT_ENC
  WHERE CONSENT_TYPE_C_NAME IS NOT NULL
  GROUP BY CONSENT_TYPE_C_NAME
)
SELECT 
  category_type,
  value,
  usage_count
FROM all_categories
WHERE value != ''  -- Skip empty strings
ORDER BY category_type, usage_count DESC;
</example-query>

---

### Navigation Strategies

#### Finding Tables by Domain

<example-query description="Find diagnosis-related tables">
-- Find tables with documentation mentioning 'diagnosis'
SELECT DISTINCT table_name
FROM _metadata
WHERE documentation LIKE '%diagnosis%'
ORDER BY table_name;
</example-query>

#### Discovering Column Relationships

<example-query description="Find potential foreign keys to PATIENT">
-- Find all columns named PAT_ID and their tables
SELECT 
  table_name,
  documentation
FROM _metadata
WHERE column_name = 'PAT_ID'
ORDER BY table_name
LIMIT 10;
</example-query>

---

### Working with Epic's Patterns

#### Best Practices

1. **Trust the _C_NAME values**: They're denormalized for a reason—use them
2. **Build reference tables early**: Extract distinct category values immediately
3. **Document your discoveries**: Epic's naming is consistent but not always obvious
4. **Use prefixes for exploration**: Start with module prefix to narrow scope

#### Common Pitfalls

- **Don't expect ZC_ tables**: They're rarely in exports
- **Don't assume codes exist**: Often only _C_NAME is populated
- **Don't fight denormalization**: It's Epic's performance optimization
- **Don't ignore empty strings**: They're different from NULL in Epic

#### Creating Your Own Tables

Follow Epic's patterns for consistency:

<example-query description="Example: Creating analysis tables following Epic patterns">
-- Good: Follows Epic naming conventions
SELECT 
  'CREATE TABLE ANALYSIS_PAT_RISK (' as ddl
UNION ALL SELECT '  PAT_ID TEXT,'
UNION ALL SELECT '  RISK_SCORE_C INTEGER,'
UNION ALL SELECT '  RISK_SCORE_C_NAME TEXT,'
UNION ALL SELECT '  CALC_DTTM TEXT,'
UNION ALL SELECT '  CALC_USER_ID TEXT'
UNION ALL SELECT ');';
</example-query>

---

### Quick Reference Card

**Module Prefixes**:
```
Clinical:  PAT_, ORDER_, MED_, IP_
Financial: HSP_, ARPB_, COVERAGE_
Reference: CLARITY_, CL_
Portal:    MYC_
History:   *_HX
Views:     V_
```

**Column Suffixes**:
```
Identity:  _ID
Category:  _C, _C_NAME  
Boolean:   _YN
Temporal:  _DATE, _DTTM
Numeric:   _AMT, _NUM
User:      _USER_ID
```

**Finding Patterns**:
```sql
-- Tables by module
SELECT SUBSTR(name,1,INSTR(name||'_','_')-1) as prefix, COUNT(*)...

-- Reference values  
SELECT DISTINCT any_C_NAME_column FROM any_table...

-- Related tables
SELECT name FROM sqlite_master WHERE name LIKE 'PAT_%'...
```

---

### Key Takeaways

1. **Epic's naming is systematic**: Learn the patterns once, apply everywhere
2. **The _C/_C_NAME pattern is ubiquitous**: Denormalization for performance
3. **ZC_ tables are absent**: Build your own reference data
4. **Prefixes indicate modules**: Start navigation with the right prefix
5. **Suffixes reveal data types**: _ID, _YN, _DATE have consistent meanings

Epic's naming conventions are your map through the complexity. Once you internalize these patterns, those 18,000 tables become navigable neighborhoods rather than an impenetrable maze.