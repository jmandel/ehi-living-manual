# Chapter 2.4: Dates & Times

*Purpose: Master Epic's unique date encoding and learn to handle the complexities of healthcare timestamps across time zones and systems.*

### The December 31, 1840 Mystery

Epic's date system traces back to the Massachusetts General Hospital MUMPS system in 1969. The developers needed to represent birthdates for the oldest possible patients—including Civil War veterans who might be 121 years old. They chose **December 31, 1840** as day zero because it predated any living person and made every fourth year a leap year in their calculations.

This decision, made over 50 years ago, still echoes through every Epic export today.

<example-query description="Verify the Epic epoch date">
-- The magic number: days from December 31, 1840
SELECT 
  DATE('1840-12-31') as epic_epoch,
  JULIANDAY('1840-12-31') as julian_day_number,
  DATE('1840-12-31', '+1 day') as day_one
</example-query>

### Decoding CONTACT_DATE_REAL

The **PAT_ENC_DATE_REAL** field (often seen as CONTACT_DATE_REAL in other tables) packs two pieces of information into a single decimal number:

- **Integer part**: Days since December 31, 1840
- **Decimal part**: Sequence number for multiple encounters on the same day

<example-query description="Examine PAT_ENC_DATE_REAL structure">
SELECT 
  PAT_ENC_DATE_REAL,
  CAST(PAT_ENC_DATE_REAL AS INTEGER) as days_since_epoch,
  ROUND((PAT_ENC_DATE_REAL - CAST(PAT_ENC_DATE_REAL AS INTEGER)) * 100) as sequence_number,
  CONTACT_DATE as epic_formatted_date
FROM pat_enc
WHERE PAT_ENC_DATE_REAL IS NOT NULL
LIMIT 10
</example-query>

### Converting Epic Dates to Standard Formats

The conversion is straightforward once you know the formula:

<example-query description="Convert Epic dates to ISO format">
SELECT 
  PAT_ENC_CSN_ID,
  PAT_ENC_DATE_REAL,
  -- Convert to ISO date
  DATE('1840-12-31', '+' || CAST(PAT_ENC_DATE_REAL AS INTEGER) || ' days') as iso_date,
  -- Extract time portion (sequence)
  CASE 
    WHEN PAT_ENC_DATE_REAL = CAST(PAT_ENC_DATE_REAL AS INTEGER) THEN 'First/Only'
    ELSE 'Sequence #' || CAST(ROUND((PAT_ENC_DATE_REAL - CAST(PAT_ENC_DATE_REAL AS INTEGER)) * 100) AS INTEGER)
  END as visit_sequence
FROM pat_enc
WHERE PAT_ENC_DATE_REAL IS NOT NULL
ORDER BY PAT_ENC_DATE_REAL
LIMIT 20
</example-query>

### Multiple Visits on the Same Day

Healthcare is complex—patients often have multiple encounters in a single day. Epic handles this elegantly with the decimal portion:

<example-query description="Find patients with multiple same-day encounters">
SELECT 
  pe.PAT_ID,
  DATE('1840-12-31', '+' || CAST(pe.PAT_ENC_DATE_REAL AS INTEGER) || ' days') as encounter_date,
  COUNT(*) as visits_that_day,
  GROUP_CONCAT(
    PRINTF('%.2f', pe.PAT_ENC_DATE_REAL) || ' (' || COALESCE(d.DEPARTMENT_NAME, 'Unknown') || ')',
    ', '
  ) as encounter_details
FROM pat_enc pe
LEFT JOIN CLARITY_DEP d ON pe.DEPARTMENT_ID = d.DEPARTMENT_ID
WHERE pe.PAT_ENC_DATE_REAL IS NOT NULL
GROUP BY pe.PAT_ID, CAST(pe.PAT_ENC_DATE_REAL AS INTEGER)
HAVING COUNT(*) > 1
ORDER BY visits_that_day DESC, encounter_date DESC
LIMIT 10
</example-query>

### Date Field Naming Patterns

Epic uses consistent suffixes to indicate date/time field types:

<example-query description="Identify date field patterns in PAT_ENC">
SELECT 
  name as column_name,
  CASE 
    WHEN name LIKE '%_DATE_REAL' THEN 'Epic Decimal Format'
    WHEN name LIKE '%_DTTM' THEN 'DateTime String'
    WHEN name LIKE '%_TIME' THEN 'Time String' 
    WHEN name LIKE '%_DATE' AND name NOT LIKE '%_DATE_REAL' THEN 'Date String'
    WHEN name LIKE '%_INSTANT' THEN 'Epic Instant (seconds)'
    ELSE 'Other'
  END as date_type,
  type as sqlite_type
FROM pragma_table_info('PAT_ENC')
WHERE name LIKE '%DATE%' 
   OR name LIKE '%TIME%' 
   OR name LIKE '%DTTM%' 
   OR name LIKE '%INSTANT%'
ORDER BY date_type, column_name
</example-query>

### Working with Hospital Admission/Discharge Times

Hospital stay calculations are fundamental to many analyses. Epic stores these as formatted strings:

<example-query description="Calculate length of stay for hospital encounters">
SELECT 
  PAT_ENC_CSN_ID,
  HOSP_ADMSN_TIME,
  HOSP_DISCHRG_TIME,
  -- Calculate length of stay in days
  ROUND(
    JULIANDAY(
      SUBSTR(HOSP_DISCHRG_TIME, 7, 4) || '-' || 
      SUBSTR(HOSP_DISCHRG_TIME, 1, 2) || '-' || 
      SUBSTR(HOSP_DISCHRG_TIME, 4, 2)
    ) - 
    JULIANDAY(
      SUBSTR(HOSP_ADMSN_TIME, 7, 4) || '-' || 
      SUBSTR(HOSP_ADMSN_TIME, 1, 2) || '-' || 
      SUBSTR(HOSP_ADMSN_TIME, 4, 2)
    ), 1
  ) as length_of_stay_days
FROM pat_enc
WHERE HOSP_ADMSN_TIME IS NOT NULL 
  AND HOSP_DISCHRG_TIME IS NOT NULL
  AND PAT_ENC_CSN_ID IS NOT NULL
ORDER BY length_of_stay_days DESC
LIMIT 10
</example-query>

### UTC vs Local Time Challenges

Epic stores most timestamps in the server's local time zone, but some fields use UTC. The **_UTC_** naming convention usually (but not always) indicates UTC storage:

<example-query description="Find tables with UTC timestamp fields">
SELECT DISTINCT 
  m.name as table_name,
  COUNT(*) as utc_field_count
FROM sqlite_master m
WHERE m.type = 'table' 
  AND m.sql LIKE '%UTC%'
GROUP BY m.name
ORDER BY utc_field_count DESC
LIMIT 10
</example-query>

**Important**: Without explicit timezone information, you must document your assumptions:
- Most timestamps are in the Epic server's local timezone
- This is typically the hospital's main location timezone
- For multi-facility systems, this becomes complex

### Efficient Date Range Queries

When filtering by date ranges, convert your criteria to Epic format for better index usage:

<example-query description="Query encounters for a specific month efficiently">
WITH date_range AS (
  SELECT 
    JULIANDAY('2018-08-01') - JULIANDAY('1840-12-31') as start_epic,
    JULIANDAY('2018-09-01') - JULIANDAY('1840-12-31') as end_epic
)
SELECT 
  pe.PAT_ENC_CSN_ID,
  DATE('1840-12-31', '+' || CAST(pe.PAT_ENC_DATE_REAL AS INTEGER) || ' days') as encounter_date,
  COALESCE(d.DEPARTMENT_NAME, 'Unknown') as department_name
FROM pat_enc pe
CROSS JOIN date_range
LEFT JOIN CLARITY_DEP d ON pe.DEPARTMENT_ID = d.DEPARTMENT_ID
WHERE pe.PAT_ENC_DATE_REAL >= start_epic
  AND pe.PAT_ENC_DATE_REAL < end_epic
ORDER BY pe.PAT_ENC_DATE_REAL
</example-query>

### Age Calculations

Calculating age at encounter is a common requirement:

<example-query description="Calculate patient age at each encounter">
SELECT 
  pe.PAT_ENC_CSN_ID,
  DATE('1840-12-31', '+' || CAST(pe.PAT_ENC_DATE_REAL AS INTEGER) || ' days') as encounter_date,
  p.BIRTH_DATE,
  -- Calculate age in years
  CAST(
    (JULIANDAY(DATE('1840-12-31', '+' || CAST(pe.PAT_ENC_DATE_REAL AS INTEGER) || ' days')) 
     - JULIANDAY(
         SUBSTR(p.BIRTH_DATE, 7, 4) || '-' || 
         SUBSTR(p.BIRTH_DATE, 1, 2) || '-' || 
         SUBSTR(p.BIRTH_DATE, 4, 2)
       )) / 365.25 
    AS INTEGER
  ) as age_at_encounter
FROM PAT_ENC pe
JOIN PATIENT p ON pe.PAT_ID = p.PAT_ID
WHERE p.BIRTH_DATE IS NOT NULL
  AND pe.PAT_ENC_DATE_REAL IS NOT NULL
ORDER BY pe.PAT_ENC_DATE_REAL DESC
LIMIT 20
</example-query>

### Days Between Encounters

Understanding patient visit patterns often requires calculating intervals:

<example-query description="Calculate days between consecutive patient visits">
WITH encounter_sequence AS (
  SELECT 
    PAT_ID,
    PAT_ENC_CSN_ID,
    PAT_ENC_DATE_REAL,
    LAG(PAT_ENC_DATE_REAL) OVER (
      PARTITION BY PAT_ID 
      ORDER BY PAT_ENC_DATE_REAL
    ) as prev_encounter_real
  FROM pat_enc
  WHERE PAT_ENC_DATE_REAL IS NOT NULL
)
SELECT 
  PAT_ID,
  PAT_ENC_CSN_ID,
  DATE('1840-12-31', '+' || CAST(PAT_ENC_DATE_REAL AS INTEGER) || ' days') as encounter_date,
  ROUND(PAT_ENC_DATE_REAL - prev_encounter_real, 1) as days_since_last_visit
FROM encounter_sequence
WHERE prev_encounter_real IS NOT NULL
  AND PAT_ENC_DATE_REAL - prev_encounter_real > 0
ORDER BY days_since_last_visit DESC
LIMIT 20
</example-query>

### Quick Reference: Date Conversion Formulas

```sql
-- Epic to ISO Date
DATE('1840-12-31', '+' || CAST(epic_date_real AS INTEGER) || ' days')

-- ISO to Epic Date  
JULIANDAY(iso_date) - JULIANDAY('1840-12-31')

-- Epic to Excel Date (Excel's epoch is January 1, 1900)
epic_date_real - 21916

-- Extract just the date part
CAST(epic_date_real AS INTEGER)

-- Extract the sequence part
ROUND((epic_date_real - CAST(epic_date_real AS INTEGER)) * 100)

-- Parse Epic's MM/DD/YYYY string format
SUBSTR(date_string, 7, 4) || '-' || 
SUBSTR(date_string, 1, 2) || '-' || 
SUBSTR(date_string, 4, 2)
```

### Common Date Pitfalls

**Null vs Missing Dates**: Many date fields can be NULL, indicating "not applicable" rather than "unknown":

<example-query description="Analyze missing date patterns">
SELECT 
  'HOSP_ADMSN_TIME' as field_name,
  COUNT(*) as total_records,
  COUNT(HOSP_ADMSN_TIME) as has_value,
  COUNT(*) - COUNT(HOSP_ADMSN_TIME) as null_count,
  ROUND((COUNT(*) - COUNT(HOSP_ADMSN_TIME)) * 100.0 / COUNT(*), 1) as null_percentage
FROM pat_enc
UNION ALL
SELECT 
  'HOSP_DISCHRG_TIME',
  COUNT(*),
  COUNT(HOSP_DISCHRG_TIME),
  COUNT(*) - COUNT(HOSP_DISCHRG_TIME),
  ROUND((COUNT(*) - COUNT(HOSP_DISCHRG_TIME)) * 100.0 / COUNT(*), 1)
FROM pat_enc
UNION ALL
SELECT 
  'UPDATE_DATE',
  COUNT(*),
  COUNT(UPDATE_DATE),
  COUNT(*) - COUNT(UPDATE_DATE),
  ROUND((COUNT(*) - COUNT(UPDATE_DATE)) * 100.0 / COUNT(*), 1)
FROM pat_enc
</example-query>

---

### Key Takeaways

1. **CONTACT_DATE_REAL** = Days since 1840-12-31 + decimal for same-day sequence
2. The decimal portion (0.01, 0.02, etc.) indicates multiple visits on the same day
3. Most timestamps are in server local time unless marked with **_UTC_**
4. Always convert search dates to Epic format for efficient queries
5. Document your timezone assumptions—they vary by installation
