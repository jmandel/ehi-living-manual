# Chapter 4.3: ARPB Transactions

*Master the professional billing transaction flow from charge to payment to zero balance.*

### What ARPB Actually Means

**ARPB = Accounts Receivable Professional Billing**. This is Epic's system for handling physician and professional service fees, distinct from hospital facility charges. If you see a doctor in their office, the billing flows through ARPB. If you're admitted to the hospital, the room charges flow through HSP (hospital billing), but the doctor's fees still flow through ARPB.

Think of it this way:
- **Hospital billing (HSP_)**: The building, the bed, the bandages
- **Professional billing (ARPB_)**: The people who treat you

### The ARPB_TRANSACTIONS Table: Your Central Hub

The `ARPB_TRANSACTIONS` table is where every financial event in professional billing lives. Unlike hospital billing with its complex bucket system, ARPB keeps things relatively straightforward: charges go in, payments and adjustments reduce the balance.

<example-query description="Explore the structure of professional billing transactions">
SELECT 
  TX_ID,
  TX_TYPE_C_NAME,
  SERVICE_DATE,
  POST_DATE,
  AMOUNT,
  OUTSTANDING_AMT,
  PAYMENT_SOURCE_C_NAME
FROM ARPB_TRANSACTIONS
WHERE SERVICE_DATE >= '2023-01-01'
ORDER BY SERVICE_DATE DESC, TX_ID
LIMIT 10;
</example-query>

Key fields to understand:
- **TX_ID**: The unique transaction identifier
- **TX_TYPE_C_NAME**: Will be "Charge", "Payment", or "Adjustment"
- **SERVICE_DATE**: When the service was performed
- **POST_DATE**: When the transaction entered the system
- **AMOUNT**: The dollar amount (see the critical sign convention below)

### The Sign Convention: Why Negatives Matter

Epic uses a consistent sign convention that makes balance calculation simple:

<example-query description="See the sign convention in action">
SELECT 
  TX_TYPE_C_NAME,
  COUNT(*) as count,
  SUM(CASE WHEN AMOUNT > 0 THEN 1 ELSE 0 END) as positive_count,
  SUM(CASE WHEN AMOUNT < 0 THEN 1 ELSE 0 END) as negative_count,
  SUM(CASE WHEN AMOUNT = 0 THEN 1 ELSE 0 END) as zero_count
FROM ARPB_TRANSACTIONS
GROUP BY TX_TYPE_C_NAME;
</example-query>

The rule is simple but critical:
- **Charges**: Positive amounts (increase the balance)
- **Payments**: Negative amounts (decrease the balance)
- **Adjustments**: Usually negative (decrease the balance)

This means calculating a balance is just `SUM(AMOUNT)`. No complex logic needed.

### Following a Charge Through Its Lifecycle

Let's trace how a charge flows from creation to zero balance:

<example-query description="See charges with their current outstanding balance">
SELECT 
  TX_ID,
  SERVICE_DATE,
  AMOUNT as original_charge,
  OUTSTANDING_AMT as current_balance,
  AMOUNT - OUTSTANDING_AMT as amount_collected,
  CASE 
    WHEN OUTSTANDING_AMT = 0 THEN 'Fully Paid'
    WHEN OUTSTANDING_AMT = AMOUNT THEN 'Unpaid'
    ELSE 'Partially Paid'
  END as status
FROM ARPB_TRANSACTIONS
WHERE TX_TYPE_C_NAME = 'Charge'
  AND SERVICE_DATE >= '2022-01-01'
ORDER BY SERVICE_DATE DESC;
</example-query>

### Payment Matching: Connecting the Dots

When a payment comes in, Epic needs to know which charge it's paying. The `ARPB_TX_MATCH_HX` table tracks these relationships:

<example-query description="See how payments match to charges">
SELECT 
  mh.TX_ID as payment_tx_id,
  mh.MTCH_TX_HX_ID as charge_tx_id,
  mh.MTCH_TX_HX_AMT as matched_amount,
  mh.MTCH_TX_HX_DT as match_date,
  -- Get details about the charge
  chg.SERVICE_DATE,
  chg.AMOUNT as original_charge
FROM ARPB_TX_MATCH_HX mh
JOIN ARPB_TRANSACTIONS chg ON mh.MTCH_TX_HX_ID = chg.TX_ID
WHERE mh.MTCH_TX_HX_UN_DT IS NULL  -- Still matched (not reversed)
ORDER BY mh.MTCH_TX_HX_DT DESC
LIMIT 10;
</example-query>

Key insights:
- One payment can match to multiple charges
- One charge can receive multiple payments
- The `MTCH_TX_HX_UN_DT` field tells you if a match was later reversed

### Understanding EOB Data

When insurance processes a claim, they send back an **Explanation of Benefits (EOB)** detailing what they'll pay and why. Epic stores this in the `PMT_EOB_INFO_I` and `PMT_EOB_INFO_II` tables:

<example-query description="Explore EOB payment details">
SELECT 
  eob.TX_ID,
  eob.CVD_AMT as covered_amount,
  eob.NONCVD_AMT as non_covered_amount,
  eob.PAID_AMT,
  eob.COPAY_AMT,
  eob.COINS_AMT,
  eob.DED_AMT,
  eob.PAID_AMT - (CAST(eob.COPAY_AMT AS REAL) + eob.COINS_AMT + eob.DED_AMT) as insurance_paid
FROM PMT_EOB_INFO_I eob
WHERE eob.CVD_AMT > 0
ORDER BY eob.TX_ID DESC
LIMIT 10;
</example-query>

The math of an EOB:
- **Billed Amount**: What the provider charged
- **Allowed Amount**: What the insurance contract allows
- **Deductible**: What counts toward the patient's deductible
- **Copay**: Fixed amount patient owes
- **Coinsurance**: Percentage patient owes
- **Paid Amount**: What insurance actually paid

### Modifiers: The Billing Nuance

Modifiers tell the story of *how* a service was performed. They can dramatically affect payment:

<example-query description="See how modifiers are used">
SELECT 
  MODIFIER_ONE,
  COUNT(*) as usage_count,
  AVG(AMOUNT) as avg_charge,
  MIN(AMOUNT) as min_charge,
  MAX(AMOUNT) as max_charge
FROM ARPB_TRANSACTIONS
WHERE TX_TYPE_C_NAME = 'Charge'
  AND MODIFIER_ONE IS NOT NULL
GROUP BY MODIFIER_ONE
ORDER BY usage_count DESC;
</example-query>

Common modifiers you'll see:
- **25**: Significant, separately identifiable E&M service
- **26**: Professional component only
- **TC**: Technical component only
- **59**: Distinct procedural service

### The Complete Transaction Chain

Let's put it all together and see a complete payment cycle:

<example-query description="Trace complete transaction chains for recent charges">
WITH charge_summary AS (
  SELECT 
    TX_ID,
    SERVICE_DATE,
    AMOUNT as charge_amount,
    OUTSTANDING_AMT
  FROM ARPB_TRANSACTIONS
  WHERE TX_TYPE_C_NAME = 'Charge'
    AND SERVICE_DATE >= '2023-09-01'
),
payment_summary AS (
  SELECT 
    mh.MTCH_TX_HX_ID as charge_tx_id,
    COUNT(*) as payment_count,
    SUM(mh.MTCH_TX_HX_AMT) as total_matched
  FROM ARPB_TX_MATCH_HX mh
  WHERE mh.MTCH_TX_HX_UN_DT IS NULL
  GROUP BY mh.MTCH_TX_HX_ID
)
SELECT 
  cs.TX_ID,
  cs.SERVICE_DATE,
  cs.charge_amount,
  COALESCE(ps.payment_count, 0) as payments_received,
  COALESCE(ps.total_matched, 0) as amount_paid,
  cs.OUTSTANDING_AMT as remaining_balance
FROM charge_summary cs
LEFT JOIN payment_summary ps ON cs.TX_ID = ps.charge_tx_id
ORDER BY cs.SERVICE_DATE DESC;
</example-query>

### Adjustments: The Write-Offs

Adjustments reduce the amount owed, typically for contractual reasons:

<example-query description="Analyze adjustment patterns">
SELECT 
  TX_ID,
  SERVICE_DATE,
  POST_DATE,
  AMOUNT,
  OUTSTANDING_AMT,
  USER_ID_NAME
FROM ARPB_TRANSACTIONS
WHERE TX_TYPE_C_NAME = 'Adjustment'
ORDER BY POST_DATE DESC
LIMIT 10;
</example-query>

Common adjustment scenarios:
- **Contractual**: Insurance paid their allowed amount; write off the rest
- **Charity Care**: Patient qualifies for financial assistance
- **Bad Debt**: Giving up on collection
- **Administrative**: Correcting billing errors

### Putting It All Together: A Patient Statement View

Here's how you'd build a view that shows what a patient actually sees on their statement:

<example-query description="Create a patient-friendly transaction summary">
SELECT 
  SERVICE_DATE,
  CASE 
    WHEN TX_TYPE_C_NAME = 'Charge' THEN 'Service'
    WHEN TX_TYPE_C_NAME = 'Payment' THEN 
      CASE 
        WHEN PAYMENT_SOURCE_C_NAME LIKE '%Insurance%' THEN 'Insurance Payment'
        ELSE 'Payment - Thank You'
      END
    WHEN TX_TYPE_C_NAME = 'Adjustment' THEN 'Adjustment'
  END as description,
  CASE WHEN AMOUNT > 0 THEN AMOUNT ELSE 0 END as charges,
  CASE WHEN AMOUNT < 0 THEN ABS(AMOUNT) ELSE 0 END as credits,
  OUTSTANDING_AMT as balance
FROM ARPB_TRANSACTIONS
WHERE ACCOUNT_ID IN (
  SELECT DISTINCT ACCOUNT_ID 
  FROM ARPB_TRANSACTIONS 
  WHERE SERVICE_DATE >= '2023-01-01'
)
ORDER BY SERVICE_DATE, TX_ID;
</example-query>

### Pro Tips for Working with ARPB

1. **Always Check OUTSTANDING_AMT**: This field tells you the current balance, saving you from calculating it yourself.

2. **Respect the Sign Convention**: Negative amounts aren't errors - they're credits that reduce the balance.

3. **Use Match History**: The `ARPB_TX_MATCH_HX` table is your friend for understanding payment application.

4. **Watch for Voids**: Check `ARPB_TX_VOID` to ensure you're not analyzing reversed transactions.

5. **Link to Clinical Data**: Use `ACCOUNT_ID` or patient identifiers to connect financial and clinical records.

### Common Pitfalls

1. **Assuming Instant Payment Posting**: Payments can take days to post after the service date.

2. **Ignoring Zero-Dollar Transactions**: These often represent important denials or authorization issues.

3. **Missing Secondary Insurance**: After primary insurance pays, remaining balance may go to secondary insurance before the patient.

4. **Forgetting Modifiers**: A procedure with different modifiers can have vastly different reimbursement.

---

### Key Takeaways

- ARPB handles all professional (physician) billing
- The sign convention is consistent: charges positive, payments/adjustments negative
- Balance calculation is simple: just SUM(AMOUNT)
- Payment matching is tracked in detail via ARPB_TX_MATCH_HX
- EOB data explains insurance payment decisions
- The OUTSTANDING_AMT field is your friend