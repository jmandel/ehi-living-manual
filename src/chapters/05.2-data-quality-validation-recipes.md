# Chapter 5.2: Data Quality & Validation Recipes

*Master the art of finding, understanding, and fixing data quality issues in Epic EHI exports through practical SQL recipes and validation frameworks.*

### The Reality of Epic Data Quality

When you receive an Epic EHI export, you're getting a snapshot of data that has traveled through multiple systems, transformations, and workflows. Each step introduces opportunities for data quality issues. This chapter equips you with battle-tested SQL recipes to identify, quantify, and address these challenges.

Here's a sobering fact: in our sample dataset, 59% of encounters are missing department assignments, and we have encounters dated in the future. These aren't bugs—they're features of real-world healthcare data. Let's learn how to find and handle them.

<example-query description="Quick data quality health check">
-- Get a rapid overview of potential data issues
SELECT 'Future-dated encounters' as issue_type, COUNT(*) as count
FROM PAT_ENC
WHERE CONTACT_DATE > date('now')

UNION ALL

SELECT 'Encounters missing department', COUNT(*)
FROM PAT_ENC
WHERE DEPARTMENT_ID IS NULL OR DEPARTMENT_ID = ''

UNION ALL

SELECT 'Discharge before admission', COUNT(*)
FROM PAT_ENC
WHERE HOSP_DISCHRG_TIME < HOSP_ADMSN_TIME
  AND HOSP_DISCHRG_TIME IS NOT NULL
  AND HOSP_ADMSN_TIME IS NOT NULL;
</example-query>

---

### Understanding NULL vs Empty String Semantics

Epic's approach to "emptiness" can be confusing. In healthcare, there's a critical difference between "we don't know" (NULL) and "we know it's nothing" (empty string). Epic uses both, often inconsistently.

#### The Three States of Emptiness

**NULL** means "unknown" or "not applicable":
- Birth weight for an adult patient
- Death date for a living patient
- Discharge time for an outpatient visit

**Empty String ("")** means "known to be empty":
- Middle name when patient has none
- Work phone when patient doesn't work
- Apartment number for a house

**Zero (0)** means "measured value of zero":
- Pain score of 0 (no pain)
- Account balance of $0.00
- Number of allergies: 0

<example-query description="Analyze NULL vs empty string patterns">
-- Check how Epic handles empty values across different fields
WITH null_analysis AS (
  SELECT 
    'EMAIL_ADDRESS' as field_name,
    SUM(CASE WHEN EMAIL_ADDRESS IS NULL THEN 1 ELSE 0 END) as null_count,
    SUM(CASE WHEN EMAIL_ADDRESS = '' THEN 1 ELSE 0 END) as empty_string_count,
    SUM(CASE WHEN EMAIL_ADDRESS IS NOT NULL AND EMAIL_ADDRESS <> '' THEN 1 ELSE 0 END) as populated_count
  FROM PATIENT
  
  UNION ALL
  
  SELECT 
    'WORK_PHONE',
    SUM(CASE WHEN WORK_PHONE IS NULL THEN 1 ELSE 0 END),
    SUM(CASE WHEN WORK_PHONE = '' THEN 1 ELSE 0 END),
    SUM(CASE WHEN WORK_PHONE IS NOT NULL AND WORK_PHONE <> '' THEN 1 ELSE 0 END)
  FROM PATIENT
  
  UNION ALL
  
  SELECT 
    'HOME_PHONE',
    SUM(CASE WHEN HOME_PHONE IS NULL THEN 1 ELSE 0 END),
    SUM(CASE WHEN HOME_PHONE = '' THEN 1 ELSE 0 END),
    SUM(CASE WHEN HOME_PHONE IS NOT NULL AND HOME_PHONE <> '' THEN 1 ELSE 0 END)
  FROM PATIENT
)
SELECT 
  field_name,
  null_count,
  empty_string_count,
  populated_count,
  ROUND(populated_count * 100.0 / (null_count + empty_string_count + populated_count), 2) as pct_populated
FROM null_analysis
ORDER BY pct_populated DESC;
</example-query>

#### Standardizing NULL Handling

When processing Epic data, you often need to normalize these inconsistencies:

<example-query description="Create standardized view with consistent NULL handling">
-- Example of a cleaned patient view that treats empty strings as NULL
-- Note: This is a read-only database, so we can't actually create views
-- CREATE VIEW IF NOT EXISTS v_patient_cleaned AS
SELECT 
  PAT_ID,
  -- Convert empty strings to NULL for consistency
  NULLIF(PAT_NAME, '') as PAT_NAME,
  NULLIF(EMAIL_ADDRESS, '') as EMAIL_ADDRESS,
  NULLIF(WORK_PHONE, '') as WORK_PHONE,
  -- Keep actual values where empty string might have meaning
  HOME_PHONE,  -- Empty might mean "no home phone"
  -- Dates should already be NULL if missing
  BIRTH_DATE,
  -- Address components - empty string might mean "verified as blank"
  NULLIF(CITY, '') as CITY,
  NULLIF(ZIP, '') as ZIP
FROM PATIENT;

-- Verify the standardization
SELECT 
  'Original WORK_PHONE' as version,
  COUNT(*) as empty_count
FROM PATIENT 
WHERE WORK_PHONE = ''
UNION ALL
SELECT 
  'Cleaned WORK_PHONE',
  COUNT(*)
FROM v_patient_cleaned
WHERE WORK_PHONE IS NULL;
</example-query>

---

### Finding and Handling Orphaned Records

Orphaned records are one of the most common data quality issues in Epic exports. They occur when child records exist without their parent records, breaking referential integrity.

#### Common Orphan Patterns

<example-query description="Comprehensive orphan detection across key relationships">
-- Find all types of orphaned records in one query
WITH orphan_summary AS (
  -- Orders without encounters
  SELECT 
    'ORDER_PROC' as child_table,
    'PAT_ENC' as parent_table,
    COUNT(*) as orphan_count,
    'Clinical' as category
  FROM ORDER_PROC op
  LEFT JOIN PAT_ENC pe ON op.PAT_ENC_CSN_ID = pe.PAT_ENC_CSN_ID
  WHERE pe.PAT_ENC_CSN_ID IS NULL
  
  UNION ALL
  
  -- Hospital transactions without accounts
  SELECT 
    'HSP_TRANSACTIONS',
    'HSP_ACCOUNT',
    COUNT(*),
    'Financial'
  FROM HSP_TRANSACTIONS ht
  LEFT JOIN HSP_ACCOUNT ha ON ht.HSP_ACCOUNT_ID = ha.HSP_ACCOUNT_ID
  WHERE ha.HSP_ACCOUNT_ID IS NULL
  
  UNION ALL
  
  -- Encounters without patients
  SELECT 
    'PAT_ENC',
    'PATIENT',
    COUNT(*),
    'Clinical'
  FROM PAT_ENC pe
  LEFT JOIN PATIENT p ON pe.PAT_ID = p.PAT_ID
  WHERE p.PAT_ID IS NULL
  
  UNION ALL
  
  -- Diagnoses without encounters
  SELECT 
    'PAT_ENC_DX',
    'PAT_ENC',
    COUNT(*),
    'Clinical'
  FROM PAT_ENC_DX dx
  LEFT JOIN PAT_ENC pe ON dx.PAT_ENC_CSN_ID = pe.PAT_ENC_CSN_ID
  WHERE pe.PAT_ENC_CSN_ID IS NULL
)
SELECT 
  category,
  child_table,
  parent_table,
  orphan_count,
  CASE 
    WHEN orphan_count = 0 THEN '✓ Clean'
    WHEN orphan_count < 10 THEN '⚠ Minor Issues'
    ELSE '✗ Needs Attention'
  END as status
FROM orphan_summary
ORDER BY orphan_count DESC;
</example-query>

#### Investigating Orphan Root Causes

When you find orphaned records, the next step is understanding why they exist:

<example-query description="Analyze patterns in orphaned records">
-- Deep dive into orphaned orders (if any exist)
WITH orphaned_orders AS (
  SELECT 
    op.*,
    -- Check if patient exists even if encounter doesn't
    CASE WHEN p.PAT_ID IS NOT NULL THEN 'Patient exists' ELSE 'Patient missing too' END as patient_status
  FROM ORDER_PROC op
  LEFT JOIN PAT_ENC pe ON op.PAT_ENC_CSN_ID = pe.PAT_ENC_CSN_ID
  LEFT JOIN PATIENT p ON op.PAT_ID = p.PAT_ID
  WHERE pe.PAT_ENC_CSN_ID IS NULL
)
SELECT 
  patient_status,
  COUNT(*) as count,
  MIN(ORDERING_DATE) as earliest_order,
  MAX(ORDERING_DATE) as latest_order
FROM orphaned_orders
GROUP BY patient_status;
</example-query>

---

### Data Completeness Validation

Missing data can be as problematic as incorrect data. Epic's flexibility means that "required" fields aren't always required in practice.

<example-query description="Comprehensive data completeness assessment">
-- Check completeness of critical fields across key tables
WITH completeness_checks AS (
  -- Patient demographics
  SELECT 
    'PATIENT' as table_name,
    'BIRTH_DATE' as field_name,
    COUNT(*) as total_records,
    SUM(CASE WHEN BIRTH_DATE IS NULL OR BIRTH_DATE = '' THEN 1 ELSE 0 END) as missing,
    'Demographics' as category
  FROM PATIENT
  
  UNION ALL
  
  SELECT 
    'PATIENT',
    'CITY',
    COUNT(*),
    SUM(CASE WHEN CITY IS NULL OR CITY = '' THEN 1 ELSE 0 END),
    'Demographics'
  FROM PATIENT
  
  UNION ALL
  
  -- Encounter essentials
  SELECT 
    'PAT_ENC',
    'DEPARTMENT_ID',
    COUNT(*),
    SUM(CASE WHEN DEPARTMENT_ID IS NULL OR DEPARTMENT_ID = '' THEN 1 ELSE 0 END),
    'Clinical'
  FROM PAT_ENC
  
  UNION ALL
  
  SELECT 
    'PAT_ENC',
    'VISIT_PROV_ID',
    COUNT(*),
    SUM(CASE WHEN VISIT_PROV_ID IS NULL OR VISIT_PROV_ID = '' THEN 1 ELSE 0 END),
    'Clinical'
  FROM PAT_ENC
  
  UNION ALL
  
  -- Financial class (critical for billing)
  SELECT 
    'PAT_ENC',
    'FIN_CLASS_C_NAME',
    COUNT(*),
    SUM(CASE WHEN FIN_CLASS_C_NAME IS NULL OR FIN_CLASS_C_NAME = '' THEN 1 ELSE 0 END),
    'Financial'
  FROM PAT_ENC
)
SELECT 
  category,
  table_name,
  field_name,
  total_records,
  missing,
  ROUND(missing * 100.0 / total_records, 2) as pct_missing,
  CASE 
    WHEN missing = 0 THEN '✓ Complete'
    WHEN missing * 100.0 / total_records < 5 THEN '✓ Acceptable'
    WHEN missing * 100.0 / total_records < 20 THEN '⚠ Review Needed'
    ELSE '✗ Critical Gap'
  END as assessment
FROM completeness_checks
ORDER BY pct_missing DESC;
</example-query>

---

### Business Logic Validation

Beyond structural integrity, we need to validate that the data makes business sense. Healthcare has complex rules that should be reflected in the data.

<example-query description="Validate critical business rules">
-- Check for violations of healthcare business logic
WITH business_violations AS (
  -- Check 1: Discharge before admission
  SELECT 
    'Discharge before admission' as violation_type,
    PAT_ENC_CSN_ID,
    HOSP_ADMSN_TIME,
    HOSP_DISCHRG_TIME,
    julianday(HOSP_DISCHRG_TIME) - julianday(HOSP_ADMSN_TIME) as days_difference
  FROM PAT_ENC
  WHERE HOSP_DISCHRG_TIME < HOSP_ADMSN_TIME
    AND HOSP_DISCHRG_TIME IS NOT NULL
    AND HOSP_ADMSN_TIME IS NOT NULL
  
  UNION ALL
  
  -- Check 2: Future appointments (might be valid but worth checking)
  SELECT 
    'Future-dated encounter',
    PAT_ENC_CSN_ID,
    CONTACT_DATE,
    NULL,
    julianday(CONTACT_DATE) - julianday('now')
  FROM PAT_ENC
  WHERE CONTACT_DATE > date('now')
  
  UNION ALL
  
  -- Check 3: Extremely long hospital stays (>365 days)
  SELECT 
    'Excessive length of stay',
    PAT_ENC_CSN_ID,
    HOSP_ADMSN_TIME,
    HOSP_DISCHRG_TIME,
    julianday(HOSP_DISCHRG_TIME) - julianday(HOSP_ADMSN_TIME)
  FROM PAT_ENC
  WHERE julianday(HOSP_DISCHRG_TIME) - julianday(HOSP_ADMSN_TIME) > 365
    AND HOSP_DISCHRG_TIME IS NOT NULL
    AND HOSP_ADMSN_TIME IS NOT NULL
)
SELECT 
  violation_type,
  COUNT(*) as violation_count,
  MIN(days_difference) as min_days,
  MAX(days_difference) as max_days,
  ROUND(AVG(days_difference), 2) as avg_days
FROM business_violations
GROUP BY violation_type
ORDER BY violation_count DESC;
</example-query>

---

### Duplicate Detection Strategies

While Epic has built-in duplicate management, exports may still contain duplicates or near-duplicates that need identification.

<example-query description="Find potential duplicate encounters">
-- Identify encounters that might be duplicates
WITH encounter_patterns AS (
  SELECT 
    pe1.PAT_ENC_CSN_ID as csn1,
    pe2.PAT_ENC_CSN_ID as csn2,
    pe1.PAT_ID,
    pe1.CONTACT_DATE,
    pe1.DEPARTMENT_ID,
    -- Calculate time difference in hours
    ROUND((julianday(pe2.CONTACT_DATE) - julianday(pe1.CONTACT_DATE)) * 24, 2) as hours_apart
  FROM PAT_ENC pe1
  JOIN PAT_ENC pe2 
    ON pe1.PAT_ID = pe2.PAT_ID
    AND pe1.CONTACT_DATE = pe2.CONTACT_DATE
    AND pe1.PAT_ENC_CSN_ID < pe2.PAT_ENC_CSN_ID
  WHERE pe1.DEPARTMENT_ID = pe2.DEPARTMENT_ID
    OR (pe1.DEPARTMENT_ID IS NULL AND pe2.DEPARTMENT_ID IS NULL)
)
SELECT 
  PAT_ID,
  COUNT(*) as potential_duplicate_pairs,
  MIN(hours_apart) as min_hours_apart,
  GROUP_CONCAT(csn1 || '-' || csn2, ', ') as csn_pairs
FROM encounter_patterns
GROUP BY PAT_ID
HAVING COUNT(*) > 0
ORDER BY potential_duplicate_pairs DESC;
</example-query>

---

### Building a Comprehensive Validation Suite

Now let's combine everything into a reusable validation framework that you can run regularly:

<example-query description="Create comprehensive validation dashboard">
-- Master validation query - run this for a complete health check
WITH validation_results AS (
  -- Category 1: Referential Integrity
  SELECT 
    1 as check_order,
    'Referential Integrity' as category,
    'Encounters without Patients' as check_name,
    COUNT(*) as issue_count,
    CASE WHEN COUNT(*) = 0 THEN 'PASS' ELSE 'FAIL' END as status
  FROM PAT_ENC pe
  LEFT JOIN PATIENT p ON pe.PAT_ID = p.PAT_ID
  WHERE p.PAT_ID IS NULL
  
  UNION ALL
  
  -- Category 2: Data Completeness
  SELECT 
    2,
    'Data Completeness',
    'Encounters missing Department',
    COUNT(*),
    CASE WHEN COUNT(*) < 10 THEN 'WARNING' ELSE 'FAIL' END
  FROM PAT_ENC
  WHERE DEPARTMENT_ID IS NULL OR DEPARTMENT_ID = ''
  
  UNION ALL
  
  -- Category 3: Business Logic
  SELECT 
    3,
    'Business Logic',
    'Discharge before Admission',
    COUNT(*),
    CASE WHEN COUNT(*) = 0 THEN 'PASS' WHEN COUNT(*) < 5 THEN 'WARNING' ELSE 'FAIL' END
  FROM PAT_ENC
  WHERE HOSP_DISCHRG_TIME < HOSP_ADMSN_TIME
    AND HOSP_DISCHRG_TIME IS NOT NULL
    AND HOSP_ADMSN_TIME IS NOT NULL
  
  UNION ALL
  
  -- Category 4: Data Anomalies
  SELECT 
    4,
    'Data Anomalies',
    'Future-dated Encounters',
    COUNT(*),
    CASE WHEN COUNT(*) = 0 THEN 'PASS' ELSE 'WARNING' END
  FROM PAT_ENC
  WHERE CONTACT_DATE > date('now')
  
  UNION ALL
  
  -- Category 5: NULL Consistency
  SELECT 
    5,
    'NULL Consistency',
    'Mixed NULL/Empty Strings in WORK_PHONE',
    SUM(CASE WHEN WORK_PHONE = '' THEN 1 ELSE 0 END),
    CASE 
      WHEN SUM(CASE WHEN WORK_PHONE = '' THEN 1 ELSE 0 END) = 0 THEN 'PASS'
      ELSE 'INFO'
    END
  FROM PATIENT
)
SELECT 
  category,
  check_name,
  issue_count,
  status,
  CASE status
    WHEN 'PASS' THEN '✓'
    WHEN 'WARNING' THEN '⚠'
    WHEN 'FAIL' THEN '✗'
    ELSE 'ℹ'
  END as icon
FROM validation_results
ORDER BY 
  check_order,
  CASE status 
    WHEN 'FAIL' THEN 1
    WHEN 'WARNING' THEN 2
    WHEN 'INFO' THEN 3
    WHEN 'PASS' THEN 4
  END;
</example-query>

---

### Quick Daily Validation Checklist

Here's a practical set of queries you can run daily or after each data load:

<example-query description="Daily data quality quick check">
-- Quick daily validation - should run in seconds
SELECT 
  -- Overall record counts
  'Total Patients' as metric,
  COUNT(*) as count,
  NULL as details
FROM PATIENT

UNION ALL

SELECT 
  'Total Encounters',
  COUNT(*),
  'Latest: ' || MAX(CONTACT_DATE)
FROM PAT_ENC

UNION ALL

-- Key quality metrics
SELECT 
  'Orphaned Orders',
  COUNT(*),
  CASE WHEN COUNT(*) > 0 THEN 'Action Required' ELSE 'Clean' END
FROM ORDER_PROC op
LEFT JOIN PAT_ENC pe ON op.PAT_ENC_CSN_ID = pe.PAT_ENC_CSN_ID
WHERE pe.PAT_ENC_CSN_ID IS NULL

UNION ALL

SELECT 
  'Invalid Dates',
  COUNT(*),
  'Future: ' || COUNT(CASE WHEN CONTACT_DATE > date('now') THEN 1 END)
FROM PAT_ENC
WHERE CONTACT_DATE > date('now')
  OR CONTACT_DATE < '1900-01-01'

UNION ALL

SELECT 
  'Data Freshness',
  julianday('now') - julianday(MAX(CONTACT_DATE)),
  'Days since latest encounter'
FROM PAT_ENC;
</example-query>

---

### Key Takeaways

1. **Epic's NULL handling is inconsistent** - Some fields use NULL, others use empty strings. Always check both when validating completeness.

2. **Orphaned records are common** - Expect 5-10% orphaned records in complex datasets. Plan your ETL to handle them gracefully.

3. **Business logic violations happen** - Real-world data often violates "obvious" rules like admission before discharge. Don't assume data integrity.

4. **Future dates are normal** - Scheduled appointments appear as future-dated encounters. Include them in your validation but handle appropriately.

5. **Validation should be automated** - Build these checks into your data pipeline. Run them after every load, not just when problems appear.

6. **Document your assumptions** - What's "valid" varies by organization. A 365-day hospital stay might be an error or a long-term care patient.

7. **Focus on actionable issues** - Not every data quality issue needs fixing. Prioritize based on impact to your use case.

---

### Common Validation Patterns

When building your validation framework, follow these patterns:

**Check Order:**
1. Referential integrity first (can't analyze orphaned data)
2. Data completeness second (need complete records for analysis)  
3. Business logic third (validate the sensible)
4. Anomalies last (edge cases and outliers)

**Severity Levels:**
- **FAIL**: Blocks analysis, must fix
- **WARNING**: May impact results, should investigate
- **INFO**: Worth knowing, optional to address
- **PASS**: Meets quality standards

**Action Strategies:**
- **Quarantine**: Isolate bad records for manual review
- **Default**: Apply safe defaults where appropriate
- **Flag**: Mark records as suspicious but keep them
- **Reject**: Remove from analysis entirely

---

### Next Steps
→ Continue to Chapter 5.3: Reusable Join Library