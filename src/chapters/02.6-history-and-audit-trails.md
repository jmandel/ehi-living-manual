# Chapter 2.6: History & Audit Trails (_HX)

*Purpose: Learn how Epic tracks every change to clinical and financial data through immutable history tables, enabling compliance reporting and point-in-time reconstruction.*

### The Audit Imperative in Healthcare

Healthcare isn't just about treating patients—it's about proving what happened, when, and by whom. Every medication change, every address update, every diagnosis revision must be tracked with forensic precision. Epic implements this through a consistent pattern: for many critical tables, there's a shadow **history table** (ending in `_HX`) that captures every change as an immutable record.

<example-query description="Count how many history tables exist in the export">
-- History tables follow the naming pattern *_HX
SELECT 
  COUNT(*) as history_table_count
FROM sqlite_master 
WHERE type = 'table' 
  AND name LIKE '%_HX';
</example-query>

### Anatomy of a History Table

#### The Core Pattern

Every history table shares a fundamental structure:

1. **Composite Primary Key**: `(ENTITY_ID, LINE)`
2. **Complete Snapshots**: Each row contains the full state at that moment
3. **Immutable Records**: INSERT-only, never UPDATE or DELETE

<example-query description="Examine the structure of a typical history table">
-- Look at PROBLEM_LIST_HX structure
-- Note the PROBLEM_LIST_ID (entity) and LINE (version) columns
SELECT 
  sql 
FROM sqlite_master 
WHERE type = 'table' 
  AND name = 'PROBLEM_LIST_HX';
</example-query>

#### The LINE Column: Your Version Number

The **LINE** column is the key to understanding history. It's a sequential integer that increments with each change:
- LINE = 1: Initial creation
- LINE = 2: First update  
- LINE = 3: Second update
- And so on...

<example-query description="See how LINE tracks charge review workflow">
-- Watch a charge move through review stages
SELECT 
  TX_ID,
  LINE,
  CR_HX_DATE as change_date,
  CR_HX_TIME as change_time,
  CR_HX_USER_ID_NAME as changed_by,
  CR_HX_ACTIVITY_C_NAME as activity
FROM ARPB_TX_CHG_REV_HX
WHERE TX_ID = 129124216
ORDER BY LINE;
</example-query>

### Tracking Changes Through Time

#### Who Changed What When

History tables meticulously track:
- **User identification**: Who made the change (may be encrypted or hidden)
- **Timestamp**: When the change occurred
- **Activity type**: What kind of change (Entry, Review, Update, etc.)
- **Complete state**: All field values at that moment

<example-query description="Track address changes for a patient">
-- See how a patient's address evolved
SELECT 
  PAT_ID,
  LINE,
  EFF_START_DATE,
  EFF_END_DATE,
  ADDR_HX_LINE1,
  CITY_HX,
  ADDR_CHNG_SOURCE_C_NAME as change_source
FROM PAT_ADDR_CHNG_HX
WHERE PAT_ID = 'Z7004242'
ORDER BY LINE;
</example-query>

#### Effective Dating

Some history tables use **effective date ranges** to show when data was valid:
- `EFF_START_DATE`: When this version became active
- `EFF_END_DATE`: When replaced (NULL if current)

This pattern is crucial for retroactive changes and corrections.

### Querying History Effectively

#### Getting the Current State

To find the most recent version of a record, you need the maximum LINE:

<example-query description="Find current state from history using window functions">
-- Modern approach using ROW_NUMBER()
WITH RankedHistory AS (
  SELECT 
    *,
    ROW_NUMBER() OVER (
      PARTITION BY PROBLEM_LIST_ID 
      ORDER BY LINE DESC
    ) as rn
  FROM PROBLEM_LIST_HX
)
SELECT 
  PROBLEM_LIST_ID,
  LINE,
  HX_DATE_OF_ENTRY,
  HX_STATUS_C_NAME,
  HX_DESCRIPTION
FROM RankedHistory 
WHERE rn = 1;
</example-query>

#### Tracking Change Frequency

Understanding how often data changes helps identify volatile records:

<example-query description="Find charges that went through multiple reviews">
-- Which charges required the most review cycles?
SELECT 
  TX_ID,
  COUNT(*) as review_count,
  MIN(CR_HX_DATE) as first_review,
  MAX(CR_HX_DATE) as last_review,
  COUNT(DISTINCT CR_HX_USER_ID_NAME) as reviewers
FROM ARPB_TX_CHG_REV_HX
WHERE CR_HX_USER_ID_NAME IS NOT NULL
GROUP BY TX_ID
HAVING COUNT(*) > 2
ORDER BY review_count DESC
LIMIT 10;
</example-query>

### Special History Patterns

#### Soft Deletes and Voids

Epic rarely performs hard deletes. Instead, it tracks deletions through:
1. **Void tables**: Separate tables tracking why something was removed
2. **NULL key values**: In history tables, NULL in the key field indicates deletion

<example-query description="Find voided transactions with reasons">
-- See voided charges and who voided them
SELECT 
  TX_ID,
  DEL_REVERSE_DATE as void_date,
  DEL_CHARGE_USER_ID_NAME as voided_by,
  VOID_REASON_C_NAME as void_reason
FROM ARPB_TX_VOID
WHERE DEL_REVERSE_DATE IS NOT NULL
LIMIT 10;
</example-query>

#### System vs User Changes

Not all changes are made by humans. Epic tracks the source:

<example-query description="Identify system-generated vs user changes">
-- See different change sources
SELECT 
  CR_HX_USER_ID_NAME as change_source,
  COUNT(*) as change_count,
  CASE 
    WHEN CR_HX_USER_ID_NAME LIKE '%INTERFACE%' THEN 'System'
    WHEN CR_HX_USER_ID_NAME LIKE '%EDI%' THEN 'System'
    WHEN CR_HX_USER_ID_NAME LIKE '%BATCH%' THEN 'System'
    ELSE 'User'
  END as source_type
FROM ARPB_TX_CHG_REV_HX
WHERE CR_HX_USER_ID_NAME IS NOT NULL
GROUP BY CR_HX_USER_ID_NAME
ORDER BY change_count DESC;
</example-query>

### Compliance and Regulatory Implications

#### HIPAA Requirements

The Health Insurance Portability and Accountability Act (HIPAA) mandates comprehensive audit trails. Epic's history tables provide:

- **User Attribution**: Every change linked to a specific user
- **Timestamp Precision**: Exact timing of all modifications  
- **Data Integrity**: Immutable records that cannot be altered
- **Long-term Retention**: Support for multi-year retention requirements

#### Building Audit Reports

<example-query description="Create a basic audit report for compliance">
-- Patient address change audit report
SELECT 
  p.PAT_NAME,
  p.PAT_MRN_ID,
  h.LINE as version,
  h.EFF_START_DATE as changed_on,
  h.ADDR_HX_LINE1 as new_address,
  h.CITY_HX as new_city,
  h.ADDR_CHNG_SOURCE_C_NAME as changed_via
FROM PAT_ADDR_CHNG_HX h
JOIN PATIENT p ON h.PAT_ID = p.PAT_ID
WHERE h.EFF_START_DATE >= date('now', '-1 year')
ORDER BY p.PAT_ID, h.LINE;
</example-query>

### Performance Considerations

History tables can become massive—often larger than their parent tables. Key strategies:

1. **Always filter by entity first**: Use the primary key efficiently
2. **Include date ranges**: Limit temporal scope when possible
3. **Consider materialized views**: For frequently-needed current states

<example-query description="Efficient history query pattern">
-- Good: Uses index efficiently
SELECT * 
FROM PROBLEM_LIST_HX 
WHERE PROBLEM_LIST_ID = 30694847
  AND HX_DATE_OF_ENTRY >= '2024-01-01';

-- Avoid: Full table scan
-- SELECT * FROM PROBLEM_LIST_HX 
-- WHERE HX_DATE_OF_ENTRY >= '2024-01-01';
</example-query>

### Common Pitfalls

#### 1. Assuming Sequential LINEs

<example-query description="Check for gaps in LINE sequences">
-- LINEs might have gaps - don't assume LINE = 2 follows LINE = 1
WITH line_gaps AS (
  SELECT 
    TX_ID,
    LINE,
    LAG(LINE) OVER (PARTITION BY TX_ID ORDER BY LINE) as prev_line,
    LINE - LAG(LINE) OVER (PARTITION BY TX_ID ORDER BY LINE) as gap
  FROM ARPB_TX_CHG_REV_HX
)
SELECT 
  TX_ID,
  LINE,
  prev_line,
  gap
FROM line_gaps
WHERE gap > 1
LIMIT 5;
</example-query>

#### 2. Ignoring Empty History

Not all data has history. A record might exist in the parent table but have no _HX entries:

<example-query description="Find the relationship between parent and history tables">
-- Compare parent vs history record counts
SELECT 
  'PROBLEM_LIST' as table_type,
  COUNT(*) as record_count
FROM PROBLEM_LIST
UNION ALL
SELECT 
  'PROBLEM_LIST_HX',
  COUNT(DISTINCT PROBLEM_LIST_ID)
FROM PROBLEM_LIST_HX;
</example-query>

### Practical Applications

#### Reconstructing Deleted Data

Even when data is "deleted," history preserves it:

<example-query description="View phone number history tracking">
-- Phone number change history is tracked in dedicated history tables
SELECT 
  ACCOUNT_ID,
  PHONE_NUMBER,
  CHANGE_DATE,
  CHANGE_SOURCE_C_NAME_ as change_source
FROM ACCT_HOME_PHONE_HX
ORDER BY CHANGE_DATE DESC;
-- This shows how Epic tracks historical values when phone numbers change
</example-query>

#### Change Velocity Analysis

Understanding how quickly data changes helps identify data quality issues:

<example-query description="Analyze change patterns across history tables">
-- Summary of history table activity
SELECT 
  'PAT_ADDR_CHNG_HX' as history_table,
  COUNT(*) as total_changes,
  COUNT(DISTINCT PAT_ID) as entities_changed,
  ROUND(CAST(COUNT(*) AS FLOAT) / COUNT(DISTINCT PAT_ID), 2) as avg_changes_per_entity
FROM PAT_ADDR_CHNG_HX
UNION ALL
SELECT 
  'PROBLEM_LIST_HX',
  COUNT(*),
  COUNT(DISTINCT PROBLEM_LIST_ID),
  ROUND(CAST(COUNT(*) AS FLOAT) / COUNT(DISTINCT PROBLEM_LIST_ID), 2)
FROM PROBLEM_LIST_HX
UNION ALL
SELECT 
  'ARPB_TX_CHG_REV_HX',
  COUNT(*),
  COUNT(DISTINCT TX_ID),
  ROUND(CAST(COUNT(*) AS FLOAT) / COUNT(DISTINCT TX_ID), 2)
FROM ARPB_TX_CHG_REV_HX;
</example-query>

---

### Key Takeaways

1. **History tables (*_HX) are Epic's audit trail** - They track every change with who, what, when
2. **LINE is your version number** - Higher LINE = more recent change
3. **Records are immutable** - INSERT-only design ensures audit integrity
4. **Soft deletes preserve data** - Deleted records remain in history
5. **Filter by entity first** - Always use the primary key for performance
6. **Not everything has history** - Check for _HX table existence
7. **Compliance is built-in** - HIPAA-ready audit trails by design