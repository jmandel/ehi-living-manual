# Chapter 6.3: SQL Recipe Library

*Purpose: Provide copy-paste SQL solutions for common Epic reporting needs, tested against real data.*

---

## Introduction

This chapter is your cookbook for Epic EHI analysis. Each recipe solves a specific reporting need, includes working SQL tested against our sample database, and explains the Epic-specific patterns involved. Think of these as building blocks—you can combine them, modify them, and extend them for your specific needs.

**How to Use This Chapter:**
- Each recipe includes a description, the complete SQL, and an explanation of key concepts
- All queries are tested against the sample database—click "Run" to see results
- Look for the "Pattern Notes" to understand Epic-specific considerations
- Combine recipes to build more complex reports

---

## Patient Flow and Encounters

### Recipe: Patient Visit History
**Use Case:** Show a chronological view of all patient encounters with key details.

<example-query description="View patient encounter history with department and provider">
SELECT 
  pe.PAT_ENC_CSN_ID,
  DATE(pe.CONTACT_DATE) as visit_date,
  dep.DEPARTMENT_NAME,
  ser.PROV_NAME as visit_provider,
  -- Calculate days since last visit using LAG
  julianday(pe.CONTACT_DATE) - 
    LAG(julianday(pe.CONTACT_DATE)) OVER (
      PARTITION BY pe.PAT_ID 
      ORDER BY pe.CONTACT_DATE
    ) as days_since_last_visit
FROM PAT_ENC pe
LEFT JOIN CLARITY_DEP dep ON pe.DEPARTMENT_ID = dep.DEPARTMENT_ID
LEFT JOIN CLARITY_SER ser ON pe.VISIT_PROV_ID = ser.PROV_ID
WHERE pe.PAT_ID = 'Z7004242'
ORDER BY pe.CONTACT_DATE DESC
LIMIT 20;
</example-query>

**Pattern Notes:**
- `PAT_ENC` is the central encounter table—every visit creates a record here
- `PAT_ENC_CSN_ID` is the unique encounter identifier (Contact Serial Number)
- Join to `CLARITY_DEP` for department names, `CLARITY_SER` for provider names
- Use window functions to calculate intervals between visits

### Recipe: Encounter Diagnoses with Primary Flag
**Use Case:** List all diagnoses for encounters, identifying primary vs secondary.

<example-query description="Show encounter diagnoses with primary diagnosis first">
SELECT 
  pe.PAT_ENC_CSN_ID,
  DATE(pe.CONTACT_DATE) as visit_date,
  dx.LINE,
  dx.PRIMARY_DX_YN,
  edg.DX_NAME
FROM PAT_ENC pe
JOIN PAT_ENC_DX dx ON pe.PAT_ENC_CSN_ID = dx.PAT_ENC_CSN_ID
JOIN CLARITY_EDG edg ON dx.DX_ID = edg.DX_ID
WHERE pe.PAT_ID = 'Z7004242'
  AND edg.DX_NAME IS NOT NULL
ORDER BY pe.CONTACT_DATE DESC, dx.PRIMARY_DX_YN DESC, dx.LINE;
</example-query>

**Pattern Notes:**
- `PAT_ENC_DX` uses the LINE pattern—multiple diagnoses per encounter
- `LINE = 1` often (but not always) indicates the primary diagnosis
- `PRIMARY_DX_YN` explicitly marks the primary diagnosis
- Join to `CLARITY_EDG` for diagnosis names and ICD-10 codes

### Recipe: Provider Schedule Utilization
**Use Case:** Analyze provider schedules and appointment patterns.

<example-query description="Provider appointment patterns by day of week">
WITH provider_appts AS (
  SELECT 
    ser.PROV_ID,
    ser.PROV_NAME,
    CASE CAST(strftime('%w', pe.CONTACT_DATE) AS INTEGER)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
    END as day_of_week,
    COUNT(*) as appt_count
  FROM PAT_ENC pe
  JOIN CLARITY_SER ser ON pe.VISIT_PROV_ID = ser.PROV_ID
  WHERE pe.CONTACT_DATE >= date('now', '-1 year')
    AND ser.PROV_NAME IS NOT NULL
  GROUP BY ser.PROV_ID, ser.PROV_NAME, day_of_week
)
SELECT 
  PROV_NAME,
  day_of_week,
  appt_count
FROM provider_appts
WHERE appt_count > 0
ORDER BY PROV_NAME, 
  CASE day_of_week
    WHEN 'Monday' THEN 1
    WHEN 'Tuesday' THEN 2
    WHEN 'Wednesday' THEN 3
    WHEN 'Thursday' THEN 4
    WHEN 'Friday' THEN 5
    WHEN 'Saturday' THEN 6
    WHEN 'Sunday' THEN 7
  END;
</example-query>

---

## Clinical Data Recipes

### Recipe: Active Medications List
**Use Case:** Show current medications for a patient with dosing information.

<example-query description="List active medications with generic names and instructions">
SELECT 
  om.ORDER_MED_ID,
  cm.GENERIC_NAME_ as medication,
  om.HV_DISCRETE_DOSE as dose,
  om.REFILLS,
  om.QUANTITY,
  DATE(om.START_DATE) as start_date,
  DATE(om.END_DATE) as end_date,
  om.ORDER_STATUS_C_NAME as status
FROM ORDER_MED om
JOIN CLARITY_MEDICATION cm ON om.MEDICATION_ID = cm.MEDICATION_ID
WHERE om.PAT_ID = 'Z7004242'
  AND om.ORDER_STATUS_C_NAME NOT IN ('Canceled', 'Discontinued')
ORDER BY om.START_DATE DESC;
</example-query>

**Pattern Notes:**
- `ORDER_MED` contains medication orders, not dispensing records
- Join to `CLARITY_MEDICATION` for drug information
- Status codes vary by organization but typically include: Active, Discontinued, Canceled
- `HV_DISCRETE_DOSE` contains structured dose information

### Recipe: Lab Results Trending
**Use Case:** Track lab values over time for clinical monitoring.

<example-query description="Trend lab results over time with reference ranges">
SELECT 
  op.DESCRIPTION as test_name,
  res.ORD_VALUE as result,
  res.REFERENCE_UNIT as units,
  res.REFERENCE_LOW,
  res.REFERENCE_HIGH,
  DATE(res.RESULT_DATE) as result_date,
  CASE 
    WHEN CAST(res.ORD_VALUE AS REAL) < CAST(res.REFERENCE_LOW AS REAL) THEN 'Low'
    WHEN CAST(res.ORD_VALUE AS REAL) > CAST(res.REFERENCE_HIGH AS REAL) THEN 'High'
    ELSE 'Normal'
  END as flag
FROM ORDER_PROC op
JOIN ORDER_RESULTS res ON op.ORDER_PROC_ID = res.ORDER_PROC_ID
WHERE op.PAT_ID = 'Z7004242'
  AND op.ORDER_TYPE_C_NAME = 'Lab'
  AND res.ORD_VALUE IS NOT NULL
  AND op.DESCRIPTION LIKE '%HEMOGLOBIN%'
ORDER BY res.RESULT_DATE DESC;
</example-query>

**Pattern Notes:**
- `ORDER_PROC` contains all orders (labs, imaging, procedures)
- `ORDER_RESULTS` has the actual result values
- Results may have multiple components (use COMPONENT_ID)
- Values are stored as text—cast for numeric comparisons

### Recipe: Problem List Summary
**Use Case:** Current active problems with onset dates and status.

<example-query description="Active problem list with ICD-10 codes">
SELECT 
  pl.PROBLEM_LIST_ID,
  pl.DESCRIPTION as problem_name,
  edg.DX_NAME as diagnosis_name,
  DATE(pl.NOTED_DATE) as onset_date,
  CASE WHEN pl.RESOLVED_DATE IS NOT NULL THEN 'Resolved' ELSE 'Active' END as status,
  DATE(pl.RESOLVED_DATE) as resolved_date
FROM PROBLEM_LIST pl
LEFT JOIN CLARITY_EDG edg ON pl.DX_ID = edg.DX_ID
JOIN PAT_PROBLEM_LIST ppl ON pl.PROBLEM_LIST_ID = ppl.PROBLEM_LIST_ID_
WHERE ppl.PAT_ID = 'Z7004242'
  AND pl.RESOLVED_DATE IS NULL
ORDER BY pl.NOTED_DATE DESC;
</example-query>

### Recipe: Immunization History
**Use Case:** Complete vaccination record with dates and lot numbers.

<example-query description="Immunization history with vaccine details">
SELECT 
  imm.IMMUNE_ID,
  ci.NAME_ as vaccine_name,
  DATE(imm.IMMUNE_DATE) as given_date,
  imm.DOSE,
  imm.IMMNZTN_DOSE_UNIT_C_NAME as dose_unit,
  imm.ROUTE_C_NAME,
  imm.SITE_C_NAME,
  imm.LOT
FROM IMMUNE imm
JOIN CLARITY_IMMUNZATN ci ON imm.IMMUNZATN_ID = ci.IMMUNZATN_ID
JOIN PAT_IMMUNIZATIONS pi ON imm.IMMUNE_ID = pi.IMMUNE_ID_
WHERE pi.PAT_ID = 'Z7004242'
ORDER BY imm.IMMUNE_DATE DESC;
</example-query>

---

## Financial and Billing Recipes

### Recipe: Hospital Account Summary
**Use Case:** Financial overview of hospital accounts with balances.

<example-query description="Hospital account balances and coverage">
SELECT 
  ha.HSP_ACCOUNT_ID,
  ha.ACCT_BILLSTS_HA_C_NAME as billing_status,
  -- Calculate totals from transactions
  (SELECT SUM(TX_AMOUNT) FROM HSP_TRANSACTIONS ht 
   WHERE ht.HSP_ACCOUNT_ID = ha.HSP_ACCOUNT_ID 
   AND ht.TX_TYPE_HA_C_NAME = 'Charge') as total_charges,
  (SELECT SUM(TX_AMOUNT) FROM HSP_TRANSACTIONS ht 
   WHERE ht.HSP_ACCOUNT_ID = ha.HSP_ACCOUNT_ID 
   AND ht.TX_TYPE_HA_C_NAME = 'Payment') as total_payments,
  DATE(ha.ADM_DATE_TIME) as admit_date,
  DATE(ha.DISCH_DATE_TIME) as discharge_date
FROM HSP_ACCOUNT ha
WHERE ha.HSP_ACCOUNT_ID IN (
  SELECT DISTINCT HSP_ACCOUNT_ID 
  FROM PAT_ENC 
  WHERE PAT_ID = 'Z7004242' 
  AND HSP_ACCOUNT_ID IS NOT NULL
)
ORDER BY ha.ADM_DATE_TIME DESC;
</example-query>

**Pattern Notes:**
- `HSP_ACCOUNT` is the financial container for hospital billing
- One HAR (HSP_ACCOUNT_ID) may span multiple encounters
- Balances are point-in-time snapshots from the export date
- Join to `HSP_TRANSACTIONS` for detailed charge/payment history

### Recipe: Transaction Detail with Buckets
**Use Case:** Detailed transaction history showing charge flow through buckets.

<example-query description="Hospital transactions by type and bucket">
SELECT 
  ht.TX_ID,
  ht.HSP_ACCOUNT_ID,
  DATE(ht.SERVICE_DATE) as service_date,
  DATE(ht.TX_POST_DATE) as post_date,
  ht.TX_TYPE_HA_C_NAME as transaction_type,
  ht.TX_AMOUNT as amount,
  ht.BUCKET_ID,
  ht.FIN_CLASS_C_NAME
FROM HSP_TRANSACTIONS ht
WHERE ht.HSP_ACCOUNT_ID IN (
  SELECT DISTINCT HSP_ACCOUNT_ID 
  FROM PAT_ENC 
  WHERE PAT_ID = 'Z7004242' 
  AND HSP_ACCOUNT_ID IS NOT NULL
)
ORDER BY ht.TX_POST_DATE DESC, ht.TX_ID;
</example-query>

**Pattern Notes:**
- Transaction types: 1=Charge, 2=Payment, 3=Adjustment
- Bucket flow tracks liability movement (pre-bill → insurance → self-pay)
- Amount signs: Charges positive, payments/adjustments negative
- SERVICE_DATE vs POST_DATE important for accrual accounting

### Recipe: Professional Billing Summary
**Use Case:** Physician charges and payments from professional billing.

<example-query description="Professional billing transactions by visit">
SELECT 
  at.TX_ID,
  at.ACCOUNT_ID,
  DATE(at.SERVICE_DATE) as service_date,
  DATE(at.POST_DATE) as post_date,
  eap.PROC_NAME_ as procedure_name,
  at.PROC_ID,
  at.TX_TYPE_C_NAME,
  at.AMOUNT,
  at.BILLING_PROV_ID
FROM ARPB_TRANSACTIONS at
LEFT JOIN CLARITY_EAP eap ON at.PROC_ID = eap.PROC_ID
WHERE at.ACCOUNT_ID IN (
  SELECT DISTINCT ACCOUNT_ID 
  FROM PAT_ENC 
  WHERE PAT_ID = 'Z7004242' 
  AND ACCOUNT_ID IS NOT NULL
)
  AND at.VOID_DATE IS NULL
ORDER BY at.SERVICE_DATE DESC, at.TX_ID;
</example-query>

---

## Data Quality and Validation Recipes

### Recipe: Data Completeness Check
**Use Case:** Identify missing or incomplete data in key fields.

<example-query description="Check for data completeness across key tables">
WITH completeness_check AS (
  SELECT 
    'PAT_ENC' as table_name,
    COUNT(*) as total_rows,
    SUM(CASE WHEN CONTACT_DATE IS NULL THEN 1 ELSE 0 END) as null_dates,
    SUM(CASE WHEN DEPARTMENT_ID IS NULL THEN 1 ELSE 0 END) as null_dept,
    SUM(CASE WHEN VISIT_PROV_ID IS NULL THEN 1 ELSE 0 END) as null_provider
  FROM PAT_ENC
  WHERE PAT_ID = 'Z7004242'
  
  UNION ALL
  
  SELECT 
    'PAT_ENC_DX',
    COUNT(*),
    SUM(CASE WHEN CONTACT_DATE IS NULL THEN 1 ELSE 0 END),
    SUM(CASE WHEN DX_ID IS NULL THEN 1 ELSE 0 END),
    0
  FROM PAT_ENC_DX
  WHERE PAT_ENC_CSN_ID IN (SELECT PAT_ENC_CSN_ID FROM PAT_ENC WHERE PAT_ID = 'Z7004242')
)
SELECT 
  table_name,
  total_rows,
  null_dates,
  null_dept,
  null_provider,
  ROUND(100.0 * (total_rows - null_dates - null_dept - null_provider) / total_rows, 1) as completeness_pct
FROM completeness_check;
</example-query>

### Recipe: Referential Integrity Check
**Use Case:** Verify foreign key relationships are intact.

<example-query description="Check for orphaned records and broken references">
-- Check for diagnoses without valid encounters
SELECT 
  'Orphaned Diagnoses' as issue,
  COUNT(*) as count
FROM PAT_ENC_DX dx
WHERE NOT EXISTS (
  SELECT 1 FROM PAT_ENC pe 
  WHERE pe.PAT_ENC_CSN_ID = dx.PAT_ENC_CSN_ID
)

UNION ALL

-- Check for orders without valid encounters
SELECT 
  'Orphaned Orders',
  COUNT(*)
FROM ORDER_PROC op
WHERE op.PAT_ENC_CSN_ID IS NOT NULL
  AND NOT EXISTS (
    SELECT 1 FROM PAT_ENC pe 
    WHERE pe.PAT_ENC_CSN_ID = op.PAT_ENC_CSN_ID
  )

UNION ALL

-- Check for results without valid orders
SELECT 
  'Orphaned Results',
  COUNT(*)
FROM ORDER_RESULTS res
WHERE NOT EXISTS (
  SELECT 1 FROM ORDER_PROC op 
  WHERE op.ORDER_PROC_ID = res.ORDER_PROC_ID
);
</example-query>

### Recipe: Date Consistency Validation
**Use Case:** Identify illogical date sequences in clinical data.

<example-query description="Find date inconsistencies in clinical workflows">
WITH date_checks AS (
  -- Medications with end date before start date
  SELECT 
    'Medication dates reversed' as issue_type,
    ORDER_MED_ID as record_id,
    'ORDER_MED' as table_name
  FROM ORDER_MED
  WHERE END_DATE < START_DATE
  
  UNION ALL
  
  -- Results dated before order
  SELECT 
    'Result before order',
    res.ORDER_PROC_ID,
    'ORDER_RESULTS'
  FROM ORDER_RESULTS res
  JOIN ORDER_PROC op ON res.ORDER_PROC_ID = op.ORDER_PROC_ID
  WHERE res.RESULT_DATE < op.ORDERING_DATE
  
  UNION ALL
  
  -- Discharge before admission
  SELECT 
    'Discharge before admission',
    HSP_ACCOUNT_ID,
    'HSP_ACCOUNT'
  FROM HSP_ACCOUNT
  WHERE DISCH_DATE_TIME < ADM_DATE_TIME
    AND DISCH_DATE_TIME IS NOT NULL
)
SELECT 
  issue_type,
  COUNT(*) as occurrence_count,
  table_name
FROM date_checks
GROUP BY issue_type, table_name;
</example-query>

---

## Performance Optimization Patterns

### Recipe: Efficient Date Range Queries
**Use Case:** Optimize queries that filter by date ranges.

<example-query description="Efficient pattern for date range filtering">
-- Good: Use indexed date columns directly
SELECT COUNT(*) as encounters_last_year
FROM PAT_ENC pe
WHERE pe.CONTACT_DATE >= date('now', '-1 year')
  AND pe.CONTACT_DATE < date('now')
  AND pe.PAT_ID = 'Z7004242';
</example-query>

**Performance Tips:**
- Always filter on indexed columns when possible
- Use date columns directly rather than date functions in WHERE clause
- Consider creating covering indexes for frequently accessed column combinations
- Batch large operations using CTEs to reduce repeated scans

### Recipe: Optimized Joining Pattern
**Use Case:** Join multiple tables efficiently using Epic's patterns.

<example-query description="Efficient multi-table join using Epic patterns">
-- Use CTEs to filter early and reduce join overhead
WITH recent_encounters AS (
  SELECT PAT_ENC_CSN_ID, CONTACT_DATE, DEPARTMENT_ID
  FROM PAT_ENC
  WHERE PAT_ID = 'Z7004242'
    AND CONTACT_DATE >= date('now', '-6 months')
),
encounter_dx AS (
  SELECT dx.PAT_ENC_CSN_ID, dx.DX_ID, dx.LINE
  FROM PAT_ENC_DX dx
  WHERE dx.PAT_ENC_CSN_ID IN (SELECT PAT_ENC_CSN_ID FROM recent_encounters)
    AND dx.PRIMARY_DX_YN = 'Y'
)
SELECT 
  re.PAT_ENC_CSN_ID,
  DATE(re.CONTACT_DATE) as visit_date,
  dep.DEPARTMENT_NAME,
  edg.DX_NAME as primary_diagnosis
FROM recent_encounters re
LEFT JOIN CLARITY_DEP dep ON re.DEPARTMENT_ID = dep.DEPARTMENT_ID
LEFT JOIN encounter_dx dx ON re.PAT_ENC_CSN_ID = dx.PAT_ENC_CSN_ID
LEFT JOIN CLARITY_EDG edg ON dx.DX_ID = edg.DX_ID
ORDER BY re.CONTACT_DATE DESC;
</example-query>

---

## Advanced Recipe Patterns

### Recipe: Patient Panel Management
**Use Case:** Identify patients due for preventive care measures.

<example-query description="Find patients due for health maintenance">
WITH last_visits AS (
  -- Find most recent visit per patient
  SELECT 
    PAT_ID,
    MAX(CONTACT_DATE) as last_visit_date,
    julianday('now') - julianday(MAX(CONTACT_DATE)) as days_since_visit
  FROM PAT_ENC
  GROUP BY PAT_ID
),
last_labs AS (
  -- Find most recent A1C for diabetic monitoring
  SELECT 
    op.PAT_ID,
    MAX(res.RESULT_DATE) as last_a1c_date,
    julianday('now') - julianday(MAX(res.RESULT_DATE)) as days_since_a1c
  FROM ORDER_PROC op
  JOIN ORDER_RESULTS res ON op.ORDER_PROC_ID = res.ORDER_PROC_ID
  WHERE op.DESCRIPTION LIKE '%A1C%'
  GROUP BY op.PAT_ID
)
SELECT 
  p.PAT_ID,
  p.PAT_NAME,
  DATE(lv.last_visit_date) as last_visit,
  lv.days_since_visit,
  DATE(ll.last_a1c_date) as last_a1c,
  ll.days_since_a1c,
  CASE 
    WHEN ll.days_since_a1c > 180 OR ll.days_since_a1c IS NULL THEN 'Due for A1C'
    WHEN lv.days_since_visit > 365 THEN 'Due for Annual Visit'
    ELSE 'Up to Date'
  END as care_status
FROM PATIENT p
LEFT JOIN last_visits lv ON p.PAT_ID = lv.PAT_ID
LEFT JOIN last_labs ll ON p.PAT_ID = ll.PAT_ID
WHERE p.CUR_PCP_PROV_ID IS NOT NULL;
</example-query>

### Recipe: Utilization Analysis
**Use Case:** Analyze healthcare utilization patterns.

<example-query description="Patient utilization summary by encounter type">
WITH utilization_summary AS (
  SELECT 
    pe.PAT_ID,
    strftime('%Y', pe.CONTACT_DATE) as year,
    dep.DEPARTMENT_NAME,
    COUNT(*) as visit_count,
    COUNT(DISTINCT DATE(pe.CONTACT_DATE)) as unique_days
  FROM PAT_ENC pe
  LEFT JOIN CLARITY_DEP dep ON pe.DEPARTMENT_ID = dep.DEPARTMENT_ID
  WHERE pe.CONTACT_DATE >= date('now', '-2 years')
  GROUP BY pe.PAT_ID, year, dep.DEPARTMENT_NAME
)
SELECT 
  PAT_ID,
  year,
  SUM(visit_count) as total_visits,
  COUNT(DISTINCT DEPARTMENT_NAME) as departments_seen,
  SUM(unique_days) as total_visit_days,
  GROUP_CONCAT(DEPARTMENT_NAME || ' (' || visit_count || ')', ', ') as department_breakdown
FROM utilization_summary
GROUP BY PAT_ID, year
ORDER BY year DESC, total_visits DESC;
</example-query>

---

## Key Takeaways

1. **Master the Core Tables**: `PAT_ENC`, `ORDER_PROC`, `HSP_ACCOUNT`, and `ARPB_TRANSACTIONS` are your foundations
2. **Understand the LINE Pattern**: Epic uses composite keys (ID + LINE) everywhere—always include both in joins
3. **Reference Tables are Your Friends**: `CLARITY_*` tables provide the human-readable names you need
4. **Dates Matter**: Pay attention to service date vs. post date, order date vs. result date
5. **Filter Early**: Use CTEs to reduce data volume before expensive joins
6. **Test Your Assumptions**: Epic's patterns can vary by organization—always validate with your actual data

## Recipe Template

When creating your own recipes, follow this pattern:

```sql
-- Recipe: [Descriptive Name]
-- Use Case: [What problem this solves]
-- Key Tables: [List main tables used]

WITH filtered_data AS (
  -- Filter and prepare your data
),
calculated_metrics AS (
  -- Perform calculations
)
SELECT 
  -- Final formatted output
FROM calculated_metrics
ORDER BY relevant_columns;
```

Remember: These recipes are starting points. Epic implementations vary, so always test and adjust for your specific environment.

---

*This chapter is part of "Epic EHI: The Missing Manual" - Continue to the appendices for additional reference materials.*