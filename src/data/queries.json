[
  {
    "id": "00-01-understanding-ehi-and-the-cures-act-0",
    "originalQuery": "SELECT \n    COUNT(DISTINCT table_name) as total_tables,\n    COUNT(*) as total_columns,\n    SUM(CASE WHEN documentation IS NOT NULL THEN 1 ELSE 0 END) as documented_columns,\n    ROUND(100.0 * SUM(CASE WHEN documentation IS NOT NULL THEN 1 ELSE 0 END) / COUNT(*), 1) as documentation_rate\nFROM _metadata\nWHERE column_name IS NOT NULL",
    "description": "View the scope of EHI data available in our export",
    "chapterId": "00-01-understanding-ehi-and-the-cures-act",
    "index": 0
  },
  {
    "id": "00-02-the-ehi-playground-0",
    "originalQuery": "SELECT \n    PAT_ENC_CSN_ID,\n    PAT_ID,\n    CONTACT_DATE,\n    ENC_CLOSED_YN\nFROM pat_enc\nWHERE CONTACT_DATE IS NOT NULL\nORDER BY CONTACT_DATE DESC\nLIMIT 5;",
    "description": "Your first EHI query - see real patient encounters",
    "chapterId": "00-02-the-ehi-playground",
    "index": 0
  },
  {
    "id": "00-02-the-ehi-playground-1",
    "originalQuery": "SELECT \n    CONTACT_DATE,\n    -- Extract just the date part\n    SUBSTR(CONTACT_DATE, 1, 10) as date_only,\n    -- Count encounters by date\n    COUNT(*) as encounters_on_date\nFROM pat_enc\nWHERE CONTACT_DATE IS NOT NULL\nGROUP BY date_only\nORDER BY encounters_on_date DESC\nLIMIT 5;",
    "description": "Understanding Epic's date formats",
    "chapterId": "00-02-the-ehi-playground",
    "index": 1
  },
  {
    "id": "00-02-the-ehi-playground-2",
    "originalQuery": "SELECT \n    p.PAT_NAME,\n    p.BIRTH_DATE,\n    COUNT(e.PAT_ENC_CSN_ID) as total_encounters\nFROM PATIENT p\nLEFT JOIN pat_enc e ON p.PAT_ID = e.PAT_ID\nGROUP BY p.PAT_ID, p.PAT_NAME, p.BIRTH_DATE;",
    "description": "Pattern 1: Join patient data with encounters",
    "chapterId": "00-02-the-ehi-playground",
    "index": 2
  },
  {
    "id": "00-02-the-ehi-playground-3",
    "originalQuery": "SELECT \n    table_name,\n    column_name,\n    documentation\nFROM _metadata\nWHERE table_name = 'PATIENT'\n  AND column_name IN ('PAT_ID', 'PAT_MRN_ID', 'BIRTH_DATE')",
    "description": "Pattern 2: Find tables by keyword using metadata",
    "chapterId": "00-02-the-ehi-playground",
    "index": 3
  },
  {
    "id": "00-03-understanding-the-metadata-table-0",
    "originalQuery": "SELECT \n    table_name,\n    column_name,\n    SUBSTR(documentation, 1, 100) || '...' as documentation_preview\nFROM _metadata\nWHERE table_name = 'PATIENT' \n  AND column_name = 'PAT_ID'\nLIMIT 1;",
    "description": "Your first look at the _metadata table structure",
    "chapterId": "00-03-understanding-the-metadata-table",
    "index": 0
  },
  {
    "id": "00-03-understanding-the-metadata-table-1",
    "originalQuery": "SELECT \n    COUNT(DISTINCT table_name) as documented_tables,\n    COUNT(*) as total_documentation_entries,\n    COUNT(CASE WHEN column_name IS NULL THEN 1 END) as table_descriptions,\n    COUNT(CASE WHEN column_name IS NOT NULL THEN 1 END) as column_descriptions\nFROM _metadata;",
    "description": "Understanding the _metadata structure",
    "chapterId": "00-03-understanding-the-metadata-table",
    "index": 1
  },
  {
    "id": "00-03-understanding-the-metadata-table-2",
    "originalQuery": "SELECT \n    table_name,\n    SUBSTR(documentation, 1, 150) as table_purpose\nFROM _metadata\nWHERE column_name IS NULL\n  AND table_name IN ('PATIENT', 'PAT_ENC', 'ORDER_MED', 'CLARITY_EDG')\nORDER BY table_name;",
    "description": "Discover what key tables do",
    "chapterId": "00-03-understanding-the-metadata-table",
    "index": 2
  },
  {
    "id": "00-03-understanding-the-metadata-table-3",
    "originalQuery": "-- Replace 'PAT_ENC' with any table name\nWITH table_info AS (\n    SELECT name as column_name, cid as column_order\n    FROM pragma_table_info('PAT_ENC')\n)\nSELECT \n    ti.column_name,\n    COALESCE(m.documentation, '(No documentation available)') as description\nFROM table_info ti\nLEFT JOIN _metadata m \n    ON m.table_name = 'PAT_ENC' \n    AND m.column_name = ti.column_name\nORDER BY ti.column_order;",
    "description": "Get full documentation for any table",
    "chapterId": "00-03-understanding-the-metadata-table",
    "index": 3
  },
  {
    "id": "00-03-understanding-the-metadata-table-4",
    "originalQuery": "SELECT DISTINCT\n    table_name,\n    COUNT(*) as relevant_columns\nFROM _metadata\nWHERE LOWER(documentation) LIKE '%diagnos%'\n  AND column_name IS NOT NULL\nGROUP BY table_name\nORDER BY relevant_columns DESC\nLIMIT 10;",
    "description": "Find all tables related to diagnoses",
    "chapterId": "00-03-understanding-the-metadata-table",
    "index": 4
  },
  {
    "id": "00-03-understanding-the-metadata-table-5",
    "originalQuery": "SELECT \n    table_name,\n    column_name,\n    SUBSTR(documentation, 1, 100) as description\nFROM _metadata\nWHERE column_name LIKE '%ADMSN%' \n   OR (LOWER(documentation) LIKE '%admission%' AND column_name LIKE '%_DT%')\nORDER BY table_name, column_name\nLIMIT 10;",
    "description": "Find all date/time columns related to admission",
    "chapterId": "00-03-understanding-the-metadata-table",
    "index": 5
  },
  {
    "id": "00-03-understanding-the-metadata-table-6",
    "originalQuery": "SELECT \n    table_name,\n    COUNT(*) as patient_linked_columns\nFROM _metadata\nWHERE column_name = 'PAT_ID'\n  AND table_name != 'PATIENT'\nGROUP BY table_name\nORDER BY table_name\nLIMIT 15;",
    "description": "Find foreign key relationships for patients",
    "chapterId": "00-03-understanding-the-metadata-table",
    "index": 6
  },
  {
    "id": "00-03-understanding-the-metadata-table-7",
    "originalQuery": "WITH all_tables AS (\n    SELECT name as table_name\n    FROM sqlite_master\n    WHERE type = 'table' AND name != '_metadata'\n),\ndocumented_tables AS (\n    SELECT DISTINCT table_name\n    FROM _metadata\n)\nSELECT \n    (SELECT COUNT(*) FROM all_tables) as total_tables,\n    (SELECT COUNT(*) FROM documented_tables) as documented_tables,\n    ROUND(\n        100.0 * (SELECT COUNT(*) FROM documented_tables) / \n        (SELECT COUNT(*) FROM all_tables), \n        1\n    ) as documentation_percentage,\n    -- List any undocumented tables\n    GROUP_CONCAT(\n        CASE \n            WHEN at.table_name NOT IN (SELECT table_name FROM documented_tables)\n            THEN at.table_name\n        END\n    ) as undocumented_tables\nFROM all_tables at;",
    "description": "Analyze metadata completeness",
    "chapterId": "00-03-understanding-the-metadata-table",
    "index": 7
  },
  {
    "id": "00-03-understanding-the-metadata-table-8",
    "originalQuery": "SELECT documentation \nFROM _metadata \nWHERE table_name = 'PAT_ENC' AND column_name = 'CONTACT_DATE';",
    "description": "First, get the documentation",
    "chapterId": "00-03-understanding-the-metadata-table",
    "index": 8
  },
  {
    "id": "00-03-understanding-the-metadata-table-9",
    "originalQuery": "SELECT \n    CONTACT_DATE,\n    COUNT(*) as encounters_on_date\nFROM PAT_ENC\nWHERE CONTACT_DATE IS NOT NULL\nGROUP BY CONTACT_DATE\nORDER BY encounters_on_date DESC\nLIMIT 5;",
    "description": "Then see actual data patterns",
    "chapterId": "00-03-understanding-the-metadata-table",
    "index": 9
  },
  {
    "id": "01-01-epic-data-architecture-0",
    "originalQuery": "-- Count tables that use the LINE pattern\nSELECT COUNT(DISTINCT table_name) as tables_with_line_column\nFROM _metadata\nWHERE column_name = 'LINE';",
    "description": "See evidence of hierarchical data in relational form",
    "chapterId": "01-01-epic-data-architecture",
    "index": 0
  },
  {
    "id": "01-01-epic-data-architecture-1",
    "originalQuery": "SELECT \n    ACCOUNT_ID,\n    LINE,\n    LETTER_NAME as contact_name,\n    CONTACT_STATUS_C_NAME,\n    CONTACT_DATE\nFROM ACCOUNT_CONTACT\nWHERE ACCOUNT_ID IN (\n    SELECT ACCOUNT_ID \n    FROM ACCOUNT_CONTACT \n    GROUP BY ACCOUNT_ID \n    HAVING COUNT(*) > 1\n)\nORDER BY ACCOUNT_ID, LINE\nLIMIT 10;",
    "description": "Observe hierarchical patterns in account contacts",
    "chapterId": "01-01-epic-data-architecture",
    "index": 1
  },
  {
    "id": "01-01-epic-data-architecture-2",
    "originalQuery": "-- Epic must handle massive transaction volumes\nSELECT \n    'Orders' as data_type, COUNT(*) as record_count FROM ORDER_PROC\nUNION ALL\nSELECT 'Results', COUNT(*) FROM ORDER_RESULTS\nUNION ALL\nSELECT 'Medications', COUNT(*) FROM ORDER_MED\nUNION ALL\nSELECT 'Encounters', COUNT(*) FROM PAT_ENC\nORDER BY record_count DESC;",
    "description": "See the scale that demands this architecture",
    "chapterId": "01-01-epic-data-architecture",
    "index": 2
  },
  {
    "id": "01-01-epic-data-architecture-3",
    "originalQuery": "-- Epic stores dates as days since 12/31/1840\nSELECT \n    column_name,\n    COUNT(DISTINCT table_name) as table_count,\n    GROUP_CONCAT(DISTINCT table_name) as appears_in_tables\nFROM _metadata\nWHERE column_name LIKE '%_REAL'\nGROUP BY column_name\nORDER BY table_count DESC\nLIMIT 5;",
    "description": "Discover Epic's internal date system",
    "chapterId": "01-01-epic-data-architecture",
    "index": 3
  },
  {
    "id": "01-01-epic-data-architecture-4",
    "originalQuery": "-- Find tables that share the same base record structure\nWITH base_tables AS (\n    SELECT DISTINCT \n        SUBSTR(table_name, 1, LENGTH(table_name) - 2) as base_name,\n        table_name\n    FROM _metadata\n    WHERE table_name LIKE '%\\_2' ESCAPE '\\'\n       OR table_name LIKE '%\\_3' ESCAPE '\\'\n       OR table_name LIKE '%\\_4' ESCAPE '\\'\n)\nSELECT \n    base_name,\n    GROUP_CONCAT(table_name, ', ') as related_tables,\n    COUNT(*) as table_count\nFROM base_tables\nGROUP BY base_name\nHAVING table_count > 1\nORDER BY table_count DESC\nLIMIT 10;",
    "description": "Trace hierarchical relationships through shared IDs",
    "chapterId": "01-01-epic-data-architecture",
    "index": 4
  },
  {
    "id": "01-01-epic-data-architecture-5",
    "originalQuery": "SELECT \n    SUBSTR(table_name, 1, 3) as prefix,\n    COUNT(*) as table_count,\n    GROUP_CONCAT(DISTINCT table_name) as example_tables\nFROM (\n    SELECT table_name\n    FROM _metadata\n    WHERE column_name IS NULL\n      AND table_name NOT LIKE '\\_%' ESCAPE '\\'\n    ORDER BY table_name\n    LIMIT 200\n)\nGROUP BY SUBSTR(table_name, 1, 3)\nHAVING COUNT(*) >= 3\nORDER BY table_count DESC\nLIMIT 10;",
    "description": "Common Epic master file prefixes",
    "chapterId": "01-01-epic-data-architecture",
    "index": 5
  },
  {
    "id": "01-02-modeling-a-simple-list-id-line-pattern-0",
    "originalQuery": "SELECT COUNT(DISTINCT table_name) as tables_with_line_column\nFROM _metadata\nWHERE column_name = 'LINE';",
    "description": "Discover the prevalence of the LINE pattern",
    "chapterId": "01-02-modeling-a-simple-list-id-line-pattern",
    "index": 0
  },
  {
    "id": "01-02-modeling-a-simple-list-id-line-pattern-1",
    "originalQuery": "SELECT \n    PAT_ENC_CSN_ID,\n    LINE,\n    DX_ID,\n    PRIMARY_DX_YN,\n    ANNOTATION\nFROM PAT_ENC_DX\nWHERE PAT_ENC_CSN_ID = 991225117\nORDER BY LINE;",
    "description": "Examine the (ID, LINE) pattern in encounter diagnoses",
    "chapterId": "01-02-modeling-a-simple-list-id-line-pattern",
    "index": 1
  },
  {
    "id": "01-02-modeling-a-simple-list-id-line-pattern-2",
    "originalQuery": "SELECT \n    PAT_ENC_CSN_ID,\n    LINE,\n    DX_ID,\n    PRIMARY_DX_YN,\n    CASE \n        WHEN PRIMARY_DX_YN = 'Y' AND LINE > 1 \n        THEN '⚠️ Primary diagnosis not in LINE 1!'\n        ELSE 'Normal'\n    END as note\nFROM PAT_ENC_DX\nWHERE PRIMARY_DX_YN = 'Y' \n  AND LINE > 1\nLIMIT 5;",
    "description": "Proof that LINE does not indicate priority",
    "chapterId": "01-02-modeling-a-simple-list-id-line-pattern",
    "index": 2
  },
  {
    "id": "01-02-modeling-a-simple-list-id-line-pattern-3",
    "originalQuery": "WITH line_analysis AS (\n    SELECT \n        table_name,\n        MIN(line) as min_line,\n        MAX(line) as max_line,\n        COUNT(DISTINCT line) as distinct_lines\n    FROM (\n        SELECT 'PAT_ENC_DX' as table_name, PAT_ENC_CSN_ID as id, LINE \n        FROM PAT_ENC_DX\n        UNION ALL\n        SELECT 'ALLERGY_REACTIONS', ALLERGY_ID, LINE \n        FROM ALLERGY_REACTIONS\n        UNION ALL\n        SELECT 'PAT_ADDRESS', PAT_ID, LINE \n        FROM PAT_ADDRESS\n    )\n    GROUP BY table_name, id\n)\nSELECT \n    table_name,\n    MIN(min_line) as always_starts_at,\n    MAX(max_line) as can_go_up_to,\n    COUNT(*) as parent_records\nFROM line_analysis\nGROUP BY table_name;",
    "description": "Verify LINE numbering always starts at 1",
    "chapterId": "01-02-modeling-a-simple-list-id-line-pattern",
    "index": 3
  },
  {
    "id": "01-02-modeling-a-simple-list-id-line-pattern-4",
    "originalQuery": "SELECT \n    table_name,\n    SUBSTR(documentation, 1, 100) || '...' as table_purpose\nFROM _metadata\nWHERE column_name IS NULL\n  AND table_name IN (\n    SELECT DISTINCT table_name \n    FROM _metadata \n    WHERE column_name = 'LINE'\n  )\nORDER BY table_name\nLIMIT 10;",
    "description": "See the variety of data using the (ID, LINE) pattern",
    "chapterId": "01-02-modeling-a-simple-list-id-line-pattern",
    "index": 4
  },
  {
    "id": "01-02-modeling-a-simple-list-id-line-pattern-5",
    "originalQuery": "SELECT \n    PAT_ENC_CSN_ID,\n    COUNT(*) as diagnosis_count,\n    MAX(LINE) as max_line_number,\n    COUNT(CASE WHEN PRIMARY_DX_YN = 'Y' THEN 1 END) as primary_dx_count\nFROM PAT_ENC_DX\nGROUP BY PAT_ENC_CSN_ID\nHAVING COUNT(*) > 2\nLIMIT 5;",
    "description": "Count items per parent correctly",
    "chapterId": "01-02-modeling-a-simple-list-id-line-pattern",
    "index": 5
  },
  {
    "id": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern-0",
    "originalQuery": "SELECT \n    table_name,\n    COUNT(*) as column_count\nFROM _metadata\nWHERE column_name IN ('GROUP_LINE', 'VALUE_LINE')\nGROUP BY table_name\nHAVING COUNT(*) = 2\nORDER BY table_name;",
    "description": "Discover tables using the grouped list pattern",
    "chapterId": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern",
    "index": 0
  },
  {
    "id": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern-1",
    "originalQuery": "-- During an encounter, providers review different aspects of patient history\n-- Each review session (GROUP_LINE) covers multiple history types (VALUE_LINE)\nSELECT \n    tp.GROUP_LINE as review_session,\n    tp.VALUE_LINE as item_number,\n    tp.HX_REVIEWED_HEADER as review_location,\n    ty.HX_REVIEWED_TYPE_C_NAME as history_type\nFROM PAT_HX_REV_TOPIC tp\nJOIN PAT_HX_REV_TYPE ty \n    ON tp.PAT_ENC_CSN_ID = ty.PAT_ENC_CSN_ID \n    AND tp.GROUP_LINE = ty.GROUP_LINE \n    AND tp.VALUE_LINE = ty.VALUE_LINE\nWHERE tp.PAT_ENC_CSN_ID = 724623985 \n    AND tp.GROUP_LINE IN (6,7)\nORDER BY tp.GROUP_LINE, tp.VALUE_LINE;",
    "description": "See the grouped list pattern in action",
    "chapterId": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern",
    "index": 1
  },
  {
    "id": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern-2",
    "originalQuery": "SELECT \n    name as column_name,\n    CASE \n        WHEN name LIKE '%_ID' THEN 'Parent identifier'\n        WHEN name = 'GROUP_LINE' THEN 'Group sequence number'\n        WHEN name = 'VALUE_LINE' THEN 'Item sequence within group'\n        ELSE 'Data column'\n    END as column_role\nFROM pragma_table_info('PAT_HX_REV_TOPIC')\nORDER BY cid;",
    "description": "Examine the structure of a grouped list table",
    "chapterId": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern",
    "index": 2
  },
  {
    "id": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern-3",
    "originalQuery": "SELECT DISTINCT\n    m1.table_name,\n    SUBSTR(m1.documentation, 1, 80) || '...' as table_purpose\nFROM _metadata m1\nWHERE m1.column_name IS NULL\n  AND m1.table_name IN (\n    SELECT table_name\n    FROM _metadata\n    WHERE column_name IN ('GROUP_LINE', 'VALUE_LINE')\n    GROUP BY table_name\n    HAVING COUNT(*) = 2\n  )\nLIMIT 5;",
    "description": "Understand the variety of grouped list applications",
    "chapterId": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern",
    "index": 3
  },
  {
    "id": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern-4",
    "originalQuery": "-- Count history types reviewed in each session\nSELECT \n    PAT_ENC_CSN_ID,\n    GROUP_LINE as review_session,\n    COUNT(*) as history_types_reviewed,\n    GROUP_CONCAT(HX_REVIEWED_TYPE_C_NAME, ', ') as types_reviewed\nFROM PAT_HX_REV_TYPE\nWHERE PAT_ENC_CSN_ID = 724623985\nGROUP BY PAT_ENC_CSN_ID, GROUP_LINE\nHAVING COUNT(*) > 1\nORDER BY GROUP_LINE;",
    "description": "Aggregate values within groups",
    "chapterId": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern",
    "index": 4
  },
  {
    "id": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern-5",
    "originalQuery": "WITH line_rules AS (\n    SELECT \n        'ORDER_RPTD_SIG_TEXT' as table_name,\n        MIN(GROUP_LINE) as min_group,\n        MAX(GROUP_LINE) as max_group,\n        MIN(VALUE_LINE) as min_value,\n        MAX(VALUE_LINE) as max_value\n    FROM ORDER_RPTD_SIG_TEXT\n    \n    UNION ALL\n    \n    SELECT \n        'IMM_ADMIN_GROUPS',\n        MIN(GROUP_LINE),\n        MAX(GROUP_LINE),\n        MIN(VALUE_LINE),\n        MAX(VALUE_LINE)\n    FROM IMM_ADMIN_GROUPS\n)\nSELECT * FROM line_rules;",
    "description": "Verify the numbering rules for grouped lists",
    "chapterId": "01-03-modeling-a-grouped-list-id-group-line-value-line-pattern",
    "index": 5
  },
  {
    "id": "01-04-modeling-history-and-change-hx-pattern-0",
    "originalQuery": "SELECT \n    COUNT(*) as history_tables,\n    GROUP_CONCAT(REPLACE(name, '_HX', ''), ', ') as tracked_entities\nFROM sqlite_master \nWHERE type = 'table' \n  AND name LIKE '%_HX'\nORDER BY name;",
    "description": "Discover the scope of history tracking",
    "chapterId": "01-04-modeling-history-and-change-hx-pattern",
    "index": 0
  },
  {
    "id": "01-04-modeling-history-and-change-hx-pattern-1",
    "originalQuery": "-- First, see a current address\nSELECT \n    PAT_ID,\n    LINE,\n    ADDRESS\nFROM PAT_ADDRESS\nWHERE PAT_ID = 'Z7004242';",
    "description": "Compare a regular table to its history counterpart",
    "chapterId": "01-04-modeling-history-and-change-hx-pattern",
    "index": 1
  },
  {
    "id": "01-04-modeling-history-and-change-hx-pattern-2",
    "originalQuery": "-- Then see the address history with full details\nSELECT \n    PAT_ID,\n    LINE,\n    EFF_START_DATE,\n    EFF_END_DATE,\n    ADDR_HX_LINE1,\n    CITY_HX,\n    ZIP_HX\nFROM PAT_ADDR_CHNG_HX\nWHERE PAT_ID = 'Z7004242'\nORDER BY EFF_START_DATE;",
    "description": "See the address change history",
    "chapterId": "01-04-modeling-history-and-change-hx-pattern",
    "index": 2
  },
  {
    "id": "01-04-modeling-history-and-change-hx-pattern-3",
    "originalQuery": "SELECT \n    PAT_ID,\n    LINE,\n    EFF_START_DATE,\n    EFF_END_DATE,\n    CASE \n        WHEN EFF_END_DATE IS NULL OR EFF_END_DATE = '' \n        THEN '✓ Currently Active'\n        ELSE 'Historical'\n    END as record_status\nFROM PAT_ADDR_CHNG_HX\nORDER BY PAT_ID, EFF_START_DATE;",
    "description": "Understand the active record pattern",
    "chapterId": "01-04-modeling-history-and-change-hx-pattern",
    "index": 3
  },
  {
    "id": "01-04-modeling-history-and-change-hx-pattern-4",
    "originalQuery": "-- What was the patient's address on August 1, 2018?\nSELECT \n    PAT_ID,\n    ADDR_HX_LINE1,\n    CITY_HX,\n    ZIP_HX,\n    EFF_START_DATE,\n    EFF_END_DATE,\n    'Note: Sample data may not contain historical addresses' as note\nFROM PAT_ADDR_CHNG_HX\nLIMIT 5;",
    "description": "Find a patient's address on a specific date",
    "chapterId": "01-04-modeling-history-and-change-hx-pattern",
    "index": 4
  },
  {
    "id": "01-04-modeling-history-and-change-hx-pattern-5",
    "originalQuery": "SELECT \n    table_name,\n    COUNT(*) as column_count,\n    GROUP_CONCAT(column_name, ', ') as example_columns\nFROM _metadata\nWHERE table_name LIKE '%_HX'\n   OR table_name LIKE '%_HX_%'\n   OR table_name LIKE '%HIST%'\n   OR table_name LIKE '%CHNG%'\nGROUP BY table_name\nORDER BY table_name\nLIMIT 10;",
    "description": "Examine different types of historical data",
    "chapterId": "01-04-modeling-history-and-change-hx-pattern",
    "index": 5
  },
  {
    "id": "01-04-modeling-history-and-change-hx-pattern-6",
    "originalQuery": "SELECT \n    column_name,\n    COUNT(DISTINCT table_name) as table_count\nFROM _metadata\nWHERE column_name LIKE '%_INST%'\n   OR column_name LIKE '%_DTTM'\n   OR column_name LIKE '%_USER%'\nGROUP BY column_name\nORDER BY table_count DESC\nLIMIT 10;",
    "description": "Identify audit tracking columns",
    "chapterId": "01-04-modeling-history-and-change-hx-pattern",
    "index": 6
  },
  {
    "id": "01-04-modeling-history-and-change-hx-pattern-7",
    "originalQuery": "WITH hx_patterns AS (\n    SELECT \n        table_name,\n        CASE \n            WHEN column_name = 'LINE' THEN 'Has LINE'\n            WHEN column_name LIKE '%EFF_START%' THEN 'Has EFF_START'\n            WHEN column_name LIKE '%EFF_END%' THEN 'Has EFF_END'\n            WHEN column_name LIKE '%UPDATE%USER%' THEN 'Has UPDATE_USER'\n            ELSE NULL\n        END as pattern\n    FROM _metadata\n    WHERE table_name LIKE '%_HX'\n)\nSELECT \n    pattern,\n    COUNT(DISTINCT table_name) as table_count,\n    GROUP_CONCAT(DISTINCT table_name) as example_tables\nFROM hx_patterns\nWHERE pattern IS NOT NULL\nGROUP BY pattern\nORDER BY table_count DESC;",
    "description": "Analyze history table structures",
    "chapterId": "01-04-modeling-history-and-change-hx-pattern",
    "index": 7
  },
  {
    "id": "01-04-modeling-history-and-change-hx-pattern-8",
    "originalQuery": "WITH all_tables AS (\n    SELECT \n        name as table_name,\n        CASE \n            WHEN name LIKE '%_HX' THEN 'History Table'\n            WHEN EXISTS (\n                SELECT 1 FROM sqlite_master sm2\n                WHERE sm2.name = sm.name || '_HX'\n            ) THEN 'Has History Table'\n            ELSE 'No History Tracking'\n        END as history_status\n    FROM sqlite_master sm\n    WHERE type = 'table' AND name != '_metadata'\n)\nSELECT \n    history_status,\n    COUNT(*) as table_count\nFROM all_tables\nGROUP BY history_status\nORDER BY table_count DESC;",
    "description": "Compare tables with and without history tracking",
    "chapterId": "01-04-modeling-history-and-change-hx-pattern",
    "index": 8
  },
  {
    "id": "01-05-modeling-categories-c-name-pattern-0",
    "originalQuery": "-- Traditional Epic systems use ZC_ tables for lookups\nSELECT \n    COUNT(*) as zc_tables_found,\n    CASE \n        WHEN COUNT(*) = 0 THEN '❌ No ZC_ lookup tables in EHI export!'\n        ELSE 'Found lookup tables'\n    END as finding\nFROM sqlite_master \nWHERE type = 'table' \n  AND name LIKE 'ZC_%';",
    "description": "Prove that ZC_ lookup tables don't exist",
    "chapterId": "01-05-modeling-categories-c-name-pattern",
    "index": 0
  },
  {
    "id": "01-05-modeling-categories-c-name-pattern-1",
    "originalQuery": "SELECT \n    COUNT(DISTINCT column_name) as category_columns,\n    COUNT(DISTINCT table_name) as tables_with_categories\nFROM _metadata\nWHERE column_name LIKE '%_C_NAME%';",
    "description": "Discover the prevalence of the _C_NAME pattern",
    "chapterId": "01-05-modeling-categories-c-name-pattern",
    "index": 1
  },
  {
    "id": "01-05-modeling-categories-c-name-pattern-2",
    "originalQuery": "-- First, see the distinct values\nSELECT \n    APPT_STATUS_C_NAME as status,\n    COUNT(*) as encounter_count\nFROM pat_enc \nWHERE APPT_STATUS_C_NAME IS NOT NULL\nGROUP BY APPT_STATUS_C_NAME\nORDER BY encounter_count DESC;",
    "description": "See category values in practice",
    "chapterId": "01-05-modeling-categories-c-name-pattern",
    "index": 2
  },
  {
    "id": "01-05-modeling-categories-c-name-pattern-3",
    "originalQuery": "SELECT \n    table_name,\n    column_name,\n    SUBSTR(documentation, 1, 100) || '...' as shows_numeric_codes\nFROM _metadata\nWHERE column_name LIKE '%_C_NAME'\n  AND documentation LIKE '%1 -%'\nLIMIT 5;",
    "description": "Find columns where documentation reveals numeric codes",
    "chapterId": "01-05-modeling-categories-c-name-pattern",
    "index": 3
  },
  {
    "id": "01-05-modeling-categories-c-name-pattern-4",
    "originalQuery": "-- Are category values consistent?\nSELECT \n    APPT_STATUS_C_NAME,\n    UPPER(APPT_STATUS_C_NAME) as uppercase,\n    LOWER(APPT_STATUS_C_NAME) as lowercase,\n    COUNT(*) as occurrences\nFROM pat_enc\nWHERE APPT_STATUS_C_NAME IS NOT NULL\nGROUP BY APPT_STATUS_C_NAME\nORDER BY APPT_STATUS_C_NAME;",
    "description": "Check for case variations in category values",
    "chapterId": "01-05-modeling-categories-c-name-pattern",
    "index": 4
  },
  {
    "id": "01-05-modeling-categories-c-name-pattern-5",
    "originalQuery": "-- Find all unique statuses across different status columns\nWITH all_statuses AS (\n    SELECT DISTINCT 'APPT_STATUS' as status_type, APPT_STATUS_C_NAME as status_value \n    FROM pat_enc WHERE APPT_STATUS_C_NAME IS NOT NULL\n    \n    UNION\n    \n    SELECT DISTINCT 'PROBLEM_STATUS', PROBLEM_STATUS_C_NAME \n    FROM PROBLEM_LIST WHERE PROBLEM_STATUS_C_NAME IS NOT NULL\n)\nSELECT * FROM all_statuses\nORDER BY status_type, status_value;",
    "description": "Demonstrate lack of referential constraints",
    "chapterId": "01-05-modeling-categories-c-name-pattern",
    "index": 5
  },
  {
    "id": "01-05-modeling-categories-c-name-pattern-6",
    "originalQuery": "WITH category_types AS (\n    SELECT \n        SUBSTR(column_name, 1, INSTR(column_name, '_C_NAME') - 1) as base_name,\n        column_name,\n        table_name\n    FROM _metadata\n    WHERE column_name LIKE '%_C_NAME%'\n)\nSELECT \n    base_name,\n    COUNT(DISTINCT table_name) as table_count,\n    GROUP_CONCAT(DISTINCT table_name) as appears_in_tables\nFROM category_types\nGROUP BY base_name\nHAVING COUNT(DISTINCT table_name) > 3\nORDER BY table_count DESC\nLIMIT 10;",
    "description": "Analyze category naming patterns",
    "chapterId": "01-05-modeling-categories-c-name-pattern",
    "index": 6
  },
  {
    "id": "01-05-modeling-categories-c-name-pattern-7",
    "originalQuery": "SELECT \n    column_name,\n    table_name,\n    documentation\nFROM _metadata\nWHERE column_name LIKE '%_C'\n  AND column_name NOT IN (\n      SELECT REPLACE(column_name, '_NAME', '') \n      FROM _metadata \n      WHERE column_name LIKE '%_C_NAME%'\n  )\nLIMIT 10;",
    "description": "Investigate _C columns without _NAME",
    "chapterId": "01-05-modeling-categories-c-name-pattern",
    "index": 7
  },
  {
    "id": "01-05-modeling-categories-c-name-pattern-8",
    "originalQuery": "-- Build a reference of all appointment statuses\nSELECT DISTINCT \n    APPT_STATUS_C_NAME as status_name,\n    COUNT(*) as usage_count\nFROM PAT_ENC\nWHERE APPT_STATUS_C_NAME IS NOT NULL\nGROUP BY APPT_STATUS_C_NAME\nORDER BY usage_count DESC;",
    "description": "Create a reference list of valid values",
    "chapterId": "01-05-modeling-categories-c-name-pattern",
    "index": 8
  },
  {
    "id": "01-06-modeling-time-real-date-pattern-0",
    "originalQuery": "-- Multiple encounters on the same day\nSELECT \n    PAT_ENC_CSN_ID,\n    CONTACT_DATE,\n    PAT_ENC_DATE_REAL\nFROM pat_enc\nWHERE CONTACT_DATE LIKE '8/9/2018%'\nORDER BY PAT_ENC_DATE_REAL;",
    "description": "See why standard dates aren't enough",
    "chapterId": "01-06-modeling-time-real-date-pattern",
    "index": 0
  },
  {
    "id": "01-06-modeling-time-real-date-pattern-1",
    "originalQuery": "-- Calculate dates from _REAL values\nSELECT \n    PAT_ENC_DATE_REAL,\n    DATE('1840-12-31', '+' || CAST(PAT_ENC_DATE_REAL AS INT) || ' days') as calculated_date,\n    SUBSTR(CONTACT_DATE, 1, 10) as actual_date,\n    CASE \n        WHEN DATE('1840-12-31', '+' || CAST(PAT_ENC_DATE_REAL AS INT) || ' days') \n             = DATE(SUBSTR(CONTACT_DATE, 7, 4) || '-' || \n                    PRINTF('%02d', CAST(SUBSTR(CONTACT_DATE, 1, INSTR(CONTACT_DATE, '/') - 1) AS INT)) || '-' ||\n                    PRINTF('%02d', CAST(SUBSTR(CONTACT_DATE, INSTR(CONTACT_DATE, '/') + 1, 2) AS INT)))\n        THEN '✓ Match!'\n        ELSE '✗ Mismatch'\n    END as verification\nFROM pat_enc\nWHERE PAT_ENC_DATE_REAL IS NOT NULL\nLIMIT 5;",
    "description": "Verify the Epic epoch date",
    "chapterId": "01-06-modeling-time-real-date-pattern",
    "index": 1
  },
  {
    "id": "01-06-modeling-time-real-date-pattern-2",
    "originalQuery": "WITH real_analysis AS (\n    SELECT \n        PAT_ID,\n        CONTACT_DATE,\n        PAT_ENC_CSN_ID,\n        PAT_ENC_DATE_REAL,\n        CAST(PAT_ENC_DATE_REAL AS INT) as date_part,\n        ROUND((PAT_ENC_DATE_REAL - CAST(PAT_ENC_DATE_REAL AS INT)) * 100, 0) as sequence_part\n    FROM pat_enc\n    WHERE CONTACT_DATE LIKE '8/9/2018%'\n)\nSELECT \n    *,\n    'Encounter #' || (sequence_part + 1) as encounter_order\nFROM real_analysis\nORDER BY PAT_ENC_DATE_REAL;",
    "description": "Analyze decimal sequencing patterns",
    "chapterId": "01-06-modeling-time-real-date-pattern",
    "index": 2
  },
  {
    "id": "01-06-modeling-time-real-date-pattern-3",
    "originalQuery": "SELECT \n    column_name,\n    COUNT(DISTINCT table_name) as table_count,\n    GROUP_CONCAT(DISTINCT table_name) as appears_in_tables\nFROM _metadata\nWHERE column_name LIKE '%_REAL'\nGROUP BY column_name\nORDER BY table_count DESC",
    "description": "Discover all _REAL date columns",
    "chapterId": "01-06-modeling-time-real-date-pattern",
    "index": 3
  },
  {
    "id": "01-06-modeling-time-real-date-pattern-4",
    "originalQuery": "-- Create a scenario showing the problem\nWITH sorting_comparison AS (\n    SELECT \n        PAT_ENC_CSN_ID,\n        CONTACT_DATE,\n        PAT_ENC_DATE_REAL,\n        -- Different sorting approaches\n        ROW_NUMBER() OVER (ORDER BY CONTACT_DATE, PAT_ENC_CSN_ID) as sort_by_date_and_id,\n        ROW_NUMBER() OVER (ORDER BY PAT_ENC_DATE_REAL) as sort_by_real,\n        -- Check if they match\n        CASE \n            WHEN ROW_NUMBER() OVER (ORDER BY CONTACT_DATE, PAT_ENC_CSN_ID) = \n                 ROW_NUMBER() OVER (ORDER BY PAT_ENC_DATE_REAL)\n            THEN 'Same'\n            ELSE 'Different!'\n        END as sort_order_match\n    FROM pat_enc\n    WHERE CONTACT_DATE LIKE '8/9/2018%'\n)\nSELECT * FROM sorting_comparison;",
    "description": "Demonstrate why _REAL sorting is essential",
    "chapterId": "01-06-modeling-time-real-date-pattern",
    "index": 4
  },
  {
    "id": "01-06-modeling-time-real-date-pattern-5",
    "originalQuery": "-- Check for any duplicate _REAL values\nWITH duplicate_check AS (\n    SELECT \n        PAT_ID,\n        PAT_ENC_DATE_REAL,\n        COUNT(*) as occurrence_count\n    FROM pat_enc\n    WHERE PAT_ENC_DATE_REAL IS NOT NULL\n    GROUP BY PAT_ID, PAT_ENC_DATE_REAL\n    HAVING COUNT(*) > 1\n)\nSELECT \n    CASE \n        WHEN COUNT(*) = 0 THEN '✓ All _REAL values are unique per patient'\n        ELSE '✗ Found ' || COUNT(*) || ' duplicates'\n    END as uniqueness_check\nFROM duplicate_check;",
    "description": "Verify _REAL values are unique per patient",
    "chapterId": "01-06-modeling-time-real-date-pattern",
    "index": 5
  },
  {
    "id": "01-06-modeling-time-real-date-pattern-6",
    "originalQuery": "SELECT \n    column_name,\n    SUBSTR(documentation, 1, 150) as description\nFROM _metadata\nWHERE column_name LIKE '%_REAL'\nORDER BY column_name\nLIMIT 5;",
    "description": "Prove decimals aren't timestamps",
    "chapterId": "01-06-modeling-time-real-date-pattern",
    "index": 6
  },
  {
    "id": "01-07-other-common-patterns-0",
    "originalQuery": "WITH pattern_analysis AS (\n    SELECT \n        CASE\n            WHEN column_name LIKE '%_YN' THEN '_YN (Yes/No)'\n            WHEN column_name LIKE '%_ID_%NAME' THEN '_ID/_NAME pairs'\n            WHEN column_name LIKE '%_AMT' THEN '_AMT (Amounts)'\n            WHEN column_name LIKE '%_DTTM' THEN '_DTTM (DateTime)'\n            WHEN column_name LIKE '%_DT' THEN '_DT (Date)'\n            WHEN column_name LIKE '%_NUM' THEN '_NUM (Number)'\n            WHEN column_name LIKE '%_CSN' THEN '_CSN (Contact Serial)'\n            ELSE 'Other'\n        END as pattern_type,\n        column_name\n    FROM _metadata\n    WHERE column_name IS NOT NULL\n)\nSELECT \n    pattern_type,\n    COUNT(*) as occurrence_count\nFROM pattern_analysis\nWHERE pattern_type != 'Other'\nGROUP BY pattern_type\nORDER BY occurrence_count DESC",
    "description": "Discover the most common column patterns",
    "chapterId": "01-07-other-common-patterns",
    "index": 0
  },
  {
    "id": "01-07-other-common-patterns-1",
    "originalQuery": "-- Check valid values\nSELECT DISTINCT \n    PRIMARY_DX_YN as yn_value,\n    COUNT(*) as occurrences\nFROM PAT_ENC_DX\nGROUP BY PRIMARY_DX_YN\nORDER BY yn_value;\n\n-- See variety of boolean fields\nSELECT \n    column_name,\n    REPLACE(column_name, '_YN', '') as what_it_tracks\nFROM _metadata\nWHERE column_name LIKE '%_YN'\n  AND table_name = 'PATIENT'\nORDER BY column_name\nLIMIT 10",
    "description": "Understand the _YN boolean pattern",
    "chapterId": "01-07-other-common-patterns",
    "index": 1
  },
  {
    "id": "01-07-other-common-patterns-2",
    "originalQuery": "-- Find examples of paired columns\nSELECT \n    REPLACE(column_name, '_NAME', '') as base_column,\n    GROUP_CONCAT(column_name, ' + ') as paired_columns\nFROM _metadata\nWHERE table_name = 'PROBLEM_LIST'\n  AND (column_name LIKE '%USER_ID' OR column_name LIKE '%USER_ID_NAME')\nGROUP BY REPLACE(column_name, '_NAME', '')\nORDER BY base_column",
    "description": "Explore ID/NAME pairs",
    "chapterId": "01-07-other-common-patterns",
    "index": 2
  },
  {
    "id": "01-07-other-common-patterns-3",
    "originalQuery": "SELECT \n    PROBLEM_LIST_ID,\n    ENTRY_USER_ID,\n    ENTRY_USER_ID_NAME,\n    DESCRIPTION\nFROM PROBLEM_LIST\nWHERE ENTRY_USER_ID IS NOT NULL\nLIMIT 5;",
    "description": "See ID/NAME pairs in action",
    "chapterId": "01-07-other-common-patterns",
    "index": 3
  },
  {
    "id": "01-07-other-common-patterns-4",
    "originalQuery": "SELECT \n    SUBSTR(name, 1, LENGTH(name) - 2) as base_table,\n    GROUP_CONCAT(name, ', ') as all_parts,\n    COUNT(*) as table_count\nFROM sqlite_master\nWHERE type = 'table'\n  AND (name LIKE '%\\_2' ESCAPE '\\' \n       OR name LIKE '%\\_3' ESCAPE '\\' \n       OR name LIKE '%\\_4' ESCAPE '\\')\nGROUP BY base_table\nHAVING table_count >= 1\nORDER BY table_count DESC\nLIMIT 10;",
    "description": "Discover continuation tables",
    "chapterId": "01-07-other-common-patterns",
    "index": 4
  },
  {
    "id": "01-07-other-common-patterns-5",
    "originalQuery": "WITH date_patterns AS (\n    SELECT \n        CASE\n            WHEN column_name LIKE '%_DTTM' THEN 'DateTime (_DTTM)'\n            WHEN column_name LIKE '%_DT' AND column_name NOT LIKE '%_DTTM' THEN 'Date only (_DT)'\n            WHEN column_name LIKE '%_DATE' THEN 'Date (spelled out)'\n            WHEN column_name LIKE '%_TIME' THEN 'Time only (_TIME)'\n            WHEN column_name LIKE '%_TM' AND column_name NOT LIKE '%_DTTM' THEN 'Time (_TM)'\n        END as pattern,\n        column_name,\n        table_name\n    FROM _metadata\n    WHERE column_name LIKE '%_DT%' \n       OR column_name LIKE '%_DATE%'\n       OR column_name LIKE '%_TIME%'\n       OR column_name LIKE '%_TM'\n)\nSELECT \n    pattern,\n    COUNT(*) as column_count,\n    SUBSTR(GROUP_CONCAT(DISTINCT column_name), 1, 100) as examples\nFROM date_patterns\nWHERE pattern IS NOT NULL\nGROUP BY pattern\nORDER BY column_count DESC\nLIMIT 5",
    "description": "Analyze temporal column patterns",
    "chapterId": "01-07-other-common-patterns",
    "index": 5
  },
  {
    "id": "01-07-other-common-patterns-6",
    "originalQuery": "SELECT \n    table_name,\n    column_name,\n    SUBSTR(documentation, 1, 100) || '...' as description\nFROM _metadata\nWHERE column_name LIKE '%_AMT'\n  AND documentation LIKE '%dollar%' OR documentation LIKE '%amount%'\nORDER BY RANDOM()\nLIMIT 5",
    "description": "Explore financial amount columns",
    "chapterId": "01-07-other-common-patterns",
    "index": 6
  },
  {
    "id": "01-07-other-common-patterns-7",
    "originalQuery": "SELECT \n    column_name,\n    COUNT(DISTINCT table_name) as used_in_tables\nFROM _metadata\nWHERE column_name LIKE '%_CSN%'\nGROUP BY column_name\nORDER BY used_in_tables DESC\nLIMIT 10",
    "description": "Understand CSN usage",
    "chapterId": "01-07-other-common-patterns",
    "index": 7
  },
  {
    "id": "01-07-other-common-patterns-8",
    "originalQuery": "SELECT \n    -- ID/NAME pair\n    ENTRY_USER_ID,\n    ENTRY_USER_ID_NAME,\n    \n    -- _YN boolean\n    CHRONIC_YN,\n    \n    -- _C_NAME category\n    PROBLEM_STATUS_C_NAME,\n    \n    -- Standard date\n    DATE_OF_ENTRY,\n    \n    -- The actual problem\n    DESCRIPTION\n    \nFROM PROBLEM_LIST\nWHERE PROBLEM_LIST_ID IS NOT NULL\nLIMIT 5;",
    "description": "See all patterns working together",
    "chapterId": "01-07-other-common-patterns",
    "index": 8
  },
  {
    "id": "02-01-patient-identity-and-demographics-0",
    "originalQuery": "SELECT \n    PAT_ID,\n    PAT_MRN_ID,\n    PAT_NAME,\n    BIRTH_DATE,\n    SEX_C_NAME\nFROM PATIENT;",
    "description": "Explore the core patient record",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 0
  },
  {
    "id": "02-01-patient-identity-and-demographics-1",
    "originalQuery": "SELECT documentation\nFROM _metadata\nWHERE table_name = 'PATIENT' \n  AND column_name IS NULL",
    "description": "View the comprehensive patient master documentation",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 1
  },
  {
    "id": "02-01-patient-identity-and-demographics-2",
    "originalQuery": "SELECT \n    PAT_ID,\n    PAT_MRN_ID,\n    -- Extract the prefix patterns\n    SUBSTR(PAT_ID, 1, 1) as pat_id_prefix,\n    SUBSTR(PAT_MRN_ID, 1, 3) as mrn_prefix\nFROM PATIENT;",
    "description": "Compare internal and external patient identifiers",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 2
  },
  {
    "id": "02-01-patient-identity-and-demographics-3",
    "originalQuery": "SELECT \n    table_name,\n    COUNT(*) as tables_with_pat_id\nFROM _metadata\nWHERE column_name = 'PAT_ID'\n  AND table_name != 'PATIENT'\nGROUP BY table_name\nORDER BY table_name\nLIMIT 10",
    "description": "Prove PAT_ID is the universal foreign key",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 3
  },
  {
    "id": "02-01-patient-identity-and-demographics-4",
    "originalQuery": "SELECT \n    PAT_NAME,\n    PAT_FIRST_NAME,\n    PAT_MIDDLE_NAME,\n    PAT_LAST_NAME\nFROM PATIENT;",
    "description": "Examine the multiple name storage formats",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 4
  },
  {
    "id": "02-01-patient-identity-and-demographics-5",
    "originalQuery": "SELECT \n    p.PAT_NAME as primary_name,\n    a.LINE,\n    a.ALIAS as alternative_name\nFROM PATIENT p\nLEFT JOIN PATIENT_ALIAS a ON p.PAT_ID = a.PAT_ID\nORDER BY a.LINE;",
    "description": "Explore patient aliases and alternative names",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 5
  },
  {
    "id": "02-01-patient-identity-and-demographics-6",
    "originalQuery": "-- Race: Stored in separate table (supports multiple selections)\nSELECT \n    'Race' as data_type,\n    pr.LINE,\n    pr.PATIENT_RACE_C_NAME as value\nFROM PATIENT_RACE pr\nWHERE pr.PAT_ID = 'Z7004242'\n\nUNION ALL\n\n-- Ethnicity: Stored directly in PATIENT table (single selection)\nSELECT \n    'Ethnicity' as data_type,\n    1 as line,\n    p.ETHNIC_GROUP_C_NAME as value\nFROM PATIENT p\nWHERE p.PAT_ID = 'Z7004242'\nORDER BY data_type, line;",
    "description": "Compare race and ethnicity storage patterns",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 6
  },
  {
    "id": "02-01-patient-identity-and-demographics-7",
    "originalQuery": "-- Permanent address components in PATIENT table\nSELECT \n    'Permanent' as address_type,\n    CITY,\n    STATE_C_NAME,\n    ZIP,\n    COUNTY_C_NAME\nFROM PATIENT\nWHERE PAT_ID = 'Z7004242'\n\nUNION ALL\n\n-- Temporary address fields (if populated)\nSELECT \n    'Temporary' as address_type,\n    TMP_CITY,\n    TMP_STATE_C_NAME,\n    TMP_ZIP,\n    TMP_COUNTY_C_NAME\nFROM PATIENT\nWHERE PAT_ID = 'Z7004242' \n  AND TMP_CITY IS NOT NULL;",
    "description": "Understand the three-tier address system",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 7
  },
  {
    "id": "02-01-patient-identity-and-demographics-8",
    "originalQuery": "SELECT \n    p.CITY,\n    p.STATE_C_NAME,\n    p.ZIP,\n    pa.LINE,\n    pa.ADDRESS as street_line\nFROM PATIENT p\nLEFT JOIN PAT_ADDRESS pa ON p.PAT_ID = pa.PAT_ID\nORDER BY pa.LINE;",
    "description": "Get complete address with street lines",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 8
  },
  {
    "id": "02-01-patient-identity-and-demographics-9",
    "originalQuery": "SELECT \n    LANGUAGE_C_NAME as primary_language,\n    LANG_CARE_C_NAME as care_language,\n    LANG_WRIT_C_NAME as written_language,\n    PREF_PCP_LANG_C_NAME as preferred_pcp_language\nFROM PATIENT;",
    "description": "Explore granular language preferences",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 9
  },
  {
    "id": "02-01-patient-identity-and-demographics-10",
    "originalQuery": "SELECT \n    'PATIENT' as table_name, COUNT(*) as column_count \nFROM pragma_table_info('PATIENT')\nUNION ALL\nSELECT \n    'PATIENT_2', COUNT(*) \nFROM pragma_table_info('PATIENT_2')\nUNION ALL\nSELECT \n    'PATIENT_3', COUNT(*) \nFROM pragma_table_info('PATIENT_3')\nORDER BY table_name;",
    "description": "Explore the continuation table pattern",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 10
  },
  {
    "id": "02-01-patient-identity-and-demographics-11",
    "originalQuery": "-- PATIENT_2: Birth details and citizenship\nSELECT \n    BIRTH_TM as birth_time,\n    IS_ADOPTED_YN,\n    CITIZENSHIP_C_NAME\nFROM PATIENT_2\nWHERE PAT_ID = 'Z7004242';",
    "description": "See specialized data in overflow tables",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 11
  },
  {
    "id": "02-01-patient-identity-and-demographics-12",
    "originalQuery": "SELECT \n    p.CUR_PCP_PROV_ID,\n    p.PREF_PCP_SEX_C_NAME,\n    p.PREF_PCP_SPEC_C_NAME,\n    p.PREF_PCP_LANG_C_NAME\nFROM PATIENT p\nWHERE p.PAT_ID = 'Z7004242';",
    "description": "Examine PCP assignment and preferences",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 12
  },
  {
    "id": "02-01-patient-identity-and-demographics-13",
    "originalQuery": "SELECT column_name\nFROM _metadata\nWHERE table_name = 'PATIENT'\n  AND (LOWER(column_name) LIKE '%gender%' \n       OR LOWER(column_name) LIKE '%sex%')\nORDER BY column_name;",
    "description": "Confirm absence of gender identity fields",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 13
  },
  {
    "id": "02-01-patient-identity-and-demographics-14",
    "originalQuery": "SELECT \n    'No merge tracking tables found' as result,\n    COUNT(*) as tables_checked\nFROM sqlite_master \nWHERE type = 'table' \n  AND (name LIKE '%MERGE%' OR name LIKE '%DUPL%');",
    "description": "Search for merge tracking tables",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 14
  },
  {
    "id": "02-01-patient-identity-and-demographics-15",
    "originalQuery": "SELECT \n    p2.RECORD_TYPE_6_C_NAME\nFROM PATIENT_2 p2\nWHERE p2.PAT_ID = 'Z7004242';",
    "description": "Check for test patient identification",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 15
  },
  {
    "id": "02-01-patient-identity-and-demographics-16",
    "originalQuery": "WITH patient_summary AS (\n    SELECT \n        p.PAT_ID,\n        p.PAT_MRN_ID,\n        p.PAT_NAME,\n        p.BIRTH_DATE,\n        -- Calculate age\n        CAST((julianday('now') - julianday(SUBSTR(p.BIRTH_DATE, 7, 4) || '-' || \n             PRINTF('%02d', CAST(SUBSTR(p.BIRTH_DATE, 1, INSTR(p.BIRTH_DATE, '/') - 1) AS INT)) || '-' ||\n             PRINTF('%02d', CAST(SUBSTR(p.BIRTH_DATE, INSTR(p.BIRTH_DATE, '/') + 1, 2) AS INT)))) / 365.25 AS INT) as age,\n        p.SEX_C_NAME,\n        p.ETHNIC_GROUP_C_NAME,\n        p.LANGUAGE_C_NAME,\n        p.CUR_PCP_PROV_ID\n    FROM PATIENT p\n)\nSELECT \n    ps.*,\n    -- Add race (concatenated if multiple)\n    GROUP_CONCAT(pr.PATIENT_RACE_C_NAME) as races,\n    -- Add address\n    pa.ADDRESS as street_address,\n    p.CITY || ', ' || p.STATE_C_NAME || ' ' || p.ZIP as city_state_zip\nFROM patient_summary ps\nJOIN PATIENT p ON ps.PAT_ID = p.PAT_ID\nLEFT JOIN PATIENT_RACE pr ON ps.PAT_ID = pr.PAT_ID\nLEFT JOIN PAT_ADDRESS pa ON ps.PAT_ID = pa.PAT_ID AND pa.LINE = 1\nGROUP BY ps.PAT_ID;",
    "description": "Create a complete patient demographic summary",
    "chapterId": "02-01-patient-identity-and-demographics",
    "index": 16
  },
  {
    "id": "02-02-encounters-and-patient-movement-0",
    "originalQuery": "SELECT \n    PAT_ENC_CSN_ID,\n    PAT_ID,\n    CONTACT_DATE,\n    APPT_STATUS_C_NAME,\n    DEPARTMENT_ID,\n    VISIT_PROV_ID\nFROM PAT_ENC\nLIMIT 5;",
    "description": "Explore the encounter master table",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 0
  },
  {
    "id": "02-02-encounters-and-patient-movement-1",
    "originalQuery": "SELECT \n    COUNT(*) as total_encounters,\n    COUNT(DISTINCT PAT_ENC_CSN_ID) as unique_csns,\n    -- CSN is the primary key\n    CASE \n        WHEN COUNT(*) = COUNT(DISTINCT PAT_ENC_CSN_ID) \n        THEN 'CSNs are unique (primary key)' \n        ELSE 'CSNs are not unique' \n    END as verification\nFROM PAT_ENC;",
    "description": "Verify CSN uniqueness and understand its role",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 1
  },
  {
    "id": "02-02-encounters-and-patient-movement-2",
    "originalQuery": "SELECT \n    table_name,\n    COUNT(*) as tables_using_csn\nFROM _metadata\nWHERE column_name = 'PAT_ENC_CSN_ID'\n  AND table_name != 'PAT_ENC'\nGROUP BY table_name\nORDER BY table_name\nLIMIT 10",
    "description": "See how CSN connects across the database",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 2
  },
  {
    "id": "02-02-encounters-and-patient-movement-3",
    "originalQuery": "SELECT \n    PAT_ID,\n    CONTACT_DATE,\n    PAT_ENC_DATE_REAL,\n    -- Extract the sequence number\n    ROUND((PAT_ENC_DATE_REAL - CAST(PAT_ENC_DATE_REAL AS INT)) * 100, 0) + 1 as encounter_sequence\nFROM PAT_ENC\nWHERE CONTACT_DATE = '9/28/2023 12:00:00 AM'\nORDER BY PAT_ENC_DATE_REAL;",
    "description": "Demonstrate the decimal date pattern",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 3
  },
  {
    "id": "02-02-encounters-and-patient-movement-4",
    "originalQuery": "WITH date_analysis AS (\n    SELECT \n        CONTACT_DATE,\n        COUNT(*) as encounters_on_date,\n        MIN(PAT_ENC_DATE_REAL) as first_encounter,\n        MAX(PAT_ENC_DATE_REAL) as last_encounter,\n        -- Calculate the decimal range\n        ROUND((MAX(PAT_ENC_DATE_REAL) - MIN(PAT_ENC_DATE_REAL)) * 100, 0) + 1 as sequential_encounters\n    FROM PAT_ENC\n    GROUP BY CONTACT_DATE\n    HAVING COUNT(*) > 1\n)\nSELECT * FROM date_analysis\nORDER BY encounters_on_date DESC\nLIMIT 5;",
    "description": "Prove decimal dates guarantee chronological ordering",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 4
  },
  {
    "id": "02-02-encounters-and-patient-movement-5",
    "originalQuery": "SELECT \n    APPT_STATUS_C_NAME,\n    COUNT(*) as count,\n    ROUND(100.0 * COUNT(*) / (SELECT COUNT(*) FROM PAT_ENC), 1) as percentage\nFROM PAT_ENC\nGROUP BY APPT_STATUS_C_NAME\nORDER BY count DESC;",
    "description": "Analyze appointment status distribution",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 5
  },
  {
    "id": "02-02-encounters-and-patient-movement-6",
    "originalQuery": "SELECT \n    -- Count populated provider fields\n    COUNT(VISIT_PROV_ID) as has_visit_provider,\n    COUNT(PCP_PROV_ID) as has_pcp,\n    -- REFERRING_PROV_ID not in this table\n    -- UPDATE_PROV_ID not in this table\n    -- Check if visit provider differs from PCP\n    SUM(CASE WHEN VISIT_PROV_ID != PCP_PROV_ID THEN 1 ELSE 0 END) as different_visit_pcp\nFROM PAT_ENC;",
    "description": "Understand the different provider roles",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 6
  },
  {
    "id": "02-02-encounters-and-patient-movement-7",
    "originalQuery": "SELECT \n    PAT_ENC_CSN_ID,\n    HOSP_ADMSN_TIME,\n    HOSP_DISCHRG_TIME,\n    -- Calculate length of stay when both times exist\n    CASE \n        WHEN HOSP_ADMSN_TIME IS NOT NULL AND HOSP_DISCHRG_TIME IS NOT NULL\n        THEN ROUND(julianday(HOSP_DISCHRG_TIME) - julianday(HOSP_ADMSN_TIME), 2)\n        ELSE NULL\n    END as los_days\nFROM PAT_ENC\nWHERE HOSP_ADMSN_TIME IS NOT NULL\nORDER BY HOSP_ADMSN_TIME\nLIMIT 5;",
    "description": "Examine hospital admission patterns",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 7
  },
  {
    "id": "02-02-encounters-and-patient-movement-8",
    "originalQuery": "SELECT \n    a.EVENT_ID,\n    a.PAT_ENC_CSN_ID,\n    a.EVENT_TYPE_C_NAME,\n    a.EFFECTIVE_TIME,\n    -- Link back to encounter\n    p.CONTACT_DATE\nFROM CLARITY_ADT a\nJOIN PAT_ENC p ON a.PAT_ENC_CSN_ID = p.PAT_ENC_CSN_ID\nORDER BY a.EFFECTIVE_TIME;",
    "description": "Explore ADT (Admission, Discharge, Transfer) events",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 8
  },
  {
    "id": "02-02-encounters-and-patient-movement-9",
    "originalQuery": "SELECT \n    EVENT_TYPE_C_NAME,\n    EFFECTIVE_TIME,\n    -- Calculate time between events\n    ROUND((julianday(EFFECTIVE_TIME) - \n           julianday(LAG(EFFECTIVE_TIME) OVER (ORDER BY EFFECTIVE_TIME))) * 24, 2) as hours_since_last_event\nFROM CLARITY_ADT\nWHERE PAT_ENC_CSN_ID = 922942674\nORDER BY EFFECTIVE_TIME;",
    "description": "Show the complete patient journey for an encounter",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 9
  },
  {
    "id": "02-02-encounters-and-patient-movement-10",
    "originalQuery": "SELECT \n    FIN_CLASS_C_NAME,\n    COUNT(*) as encounters,\n    -- Show common appointment statuses for each financial class\n    GROUP_CONCAT(DISTINCT APPT_STATUS_C_NAME) as appointment_statuses\nFROM PAT_ENC\nWHERE FIN_CLASS_C_NAME IS NOT NULL\nGROUP BY FIN_CLASS_C_NAME\nORDER BY encounters DESC;",
    "description": "Analyze financial classes across encounters",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 10
  },
  {
    "id": "02-02-encounters-and-patient-movement-11",
    "originalQuery": "SELECT \n    DEPARTMENT_ID,\n    COUNT(*) as encounter_count,\n    COUNT(DISTINCT PAT_ID) as unique_patients\nFROM PAT_ENC\nWHERE DEPARTMENT_ID IS NOT NULL\nGROUP BY DEPARTMENT_ID\nORDER BY encounter_count DESC\nLIMIT 10;",
    "description": "Find the busiest departments",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 11
  },
  {
    "id": "02-02-encounters-and-patient-movement-12",
    "originalQuery": "SELECT \n    ENC_CLOSED_YN,\n    COUNT(*) as count,\n    -- For closed encounters, check closure timing\n    AVG(CASE \n        WHEN ENC_CLOSED_YN = 'Y' AND ENC_CLOSE_DATE IS NOT NULL\n        THEN julianday(ENC_CLOSE_DATE) - julianday(CONTACT_DATE)\n        ELSE NULL\n    END) as avg_days_to_close\nFROM PAT_ENC\nGROUP BY ENC_CLOSED_YN;",
    "description": "Analyze encounter closure patterns",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 12
  },
  {
    "id": "02-02-encounters-and-patient-movement-13",
    "originalQuery": "-- Check hospital encounter data availability\nSELECT \n    COUNT(*) as total_encounters,\n    COUNT(HOSP_ADMSN_TIME) as has_admission_time,\n    COUNT(HOSP_DISCHRG_TIME) as has_discharge_time,\n    COUNT(CASE WHEN HOSP_ADMSN_TIME != '' AND HOSP_DISCHRG_TIME != '' THEN 1 END) as has_valid_times,\n    -- Note about data quality\n    'Note: Sample data may have empty timestamp fields' as data_note\nFROM PAT_ENC;",
    "description": "Calculate length of stay using different methods",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 13
  },
  {
    "id": "02-02-encounters-and-patient-movement-14",
    "originalQuery": "-- In full Epic, ENC_TYPE_C_NAME would classify encounters\nSELECT \n    'ENC_TYPE_C_NAME' as missing_column,\n    'Would classify encounters (Office Visit, Hospital, ED, etc.)' as purpose,\n    COUNT(*) as columns_in_pat_enc\nFROM _metadata\nWHERE table_name = 'PAT_ENC';",
    "description": "Check for missing encounter type classification",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 14
  },
  {
    "id": "02-02-encounters-and-patient-movement-15",
    "originalQuery": "WITH encounter_timeline AS (\n    SELECT \n        PAT_ENC_CSN_ID,\n        CONTACT_DATE,\n        PAT_ENC_DATE_REAL,\n        APPT_STATUS_C_NAME,\n        DEPARTMENT_ID,\n        VISIT_PROV_ID,\n        -- Calculate days since last encounter\n        ROUND(PAT_ENC_DATE_REAL - LAG(PAT_ENC_DATE_REAL) OVER (\n            PARTITION BY PAT_ID \n            ORDER BY PAT_ENC_DATE_REAL\n        ), 0) as days_since_last_visit\n    FROM PAT_ENC\n    WHERE PAT_ID = 'Z7004242'\n)\nSELECT * FROM encounter_timeline\nORDER BY PAT_ENC_DATE_REAL\nLIMIT 10;",
    "description": "Create a patient's encounter timeline",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 15
  },
  {
    "id": "02-02-encounters-and-patient-movement-16",
    "originalQuery": "WITH readmission_check AS (\n    SELECT \n        e1.PAT_ENC_CSN_ID as original_encounter,\n        e1.CONTACT_DATE as original_date,\n        e2.PAT_ENC_CSN_ID as potential_readmit,\n        e2.CONTACT_DATE as readmit_date,\n        ROUND(e2.PAT_ENC_DATE_REAL - e1.PAT_ENC_DATE_REAL, 0) as days_between\n    FROM PAT_ENC e1\n    JOIN PAT_ENC e2 ON e1.PAT_ID = e2.PAT_ID\n    WHERE e1.HOSP_DISCHRG_TIME IS NOT NULL\n      AND e2.HOSP_ADMSN_TIME IS NOT NULL\n      AND e2.PAT_ENC_DATE_REAL > e1.PAT_ENC_DATE_REAL\n      AND e2.PAT_ENC_DATE_REAL - e1.PAT_ENC_DATE_REAL <= 30\n)\nSELECT * FROM readmission_check\nORDER BY days_between\nLIMIT 5;",
    "description": "Find potential readmissions within 30 days",
    "chapterId": "02-02-encounters-and-patient-movement",
    "index": 16
  },
  {
    "id": "02-03-diagnoses-and-problems-0",
    "originalQuery": "-- Encounter diagnoses: Multiple per visit\nSELECT 'Encounter Diagnoses' as type, COUNT(*) as total_records\nFROM PAT_ENC_DX\n\nUNION ALL\n\n-- Problem list: Ongoing conditions\nSELECT 'Problem List', COUNT(*)\nFROM PROBLEM_LIST;",
    "description": "Compare the two diagnosis storage models",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 0
  },
  {
    "id": "02-03-diagnoses-and-problems-1",
    "originalQuery": "SELECT \n    e.PAT_ENC_CSN_ID,\n    e.LINE,\n    e.DX_ID,\n    e.PRIMARY_DX_YN,\n    -- Join to get the diagnosis name\n    d.DX_NAME\nFROM PAT_ENC_DX e\nJOIN CLARITY_EDG d ON e.DX_ID = d.DX_ID\nWHERE e.PAT_ENC_CSN_ID = 720803470\nORDER BY e.LINE;",
    "description": "Examine the encounter diagnosis structure",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 1
  },
  {
    "id": "02-03-diagnoses-and-problems-2",
    "originalQuery": "-- Find cases where primary diagnosis is NOT LINE 1\nSELECT \n    PAT_ENC_CSN_ID,\n    LINE,\n    PRIMARY_DX_YN,\n    DX_ID,\n    CASE \n        WHEN PRIMARY_DX_YN = 'Y' AND LINE > 1 \n        THEN 'Primary diagnosis at LINE ' || LINE || '!'\n        ELSE 'Normal'\n    END as note\nFROM PAT_ENC_DX\nWHERE PRIMARY_DX_YN = 'Y' AND LINE > 1\nLIMIT 5;",
    "description": "Prove that LINE does not equal priority",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 2
  },
  {
    "id": "02-03-diagnoses-and-problems-3",
    "originalQuery": "SELECT \n    DX_ID,\n    DX_NAME,\n    -- Patient-friendly description when available\n    -- DX_NAME not always present\n    DX_NAME as patient_friendly_text\nFROM CLARITY_EDG\nWHERE DX_NAME LIKE '%reflux%'\nORDER BY DX_ID;",
    "description": "Explore the diagnosis master table",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 3
  },
  {
    "id": "02-03-diagnoses-and-problems-4",
    "originalQuery": "-- Check if diagnosis tables have ICD code columns\nSELECT \n    COUNT(*) as icd_columns,\n    'Note: ICD codes appear in CLM_DX table for claims, not in clinical diagnosis tables' as explanation\nFROM _metadata\nWHERE (LOWER(column_name) LIKE '%icd%' \n       OR LOWER(column_name) LIKE '%dx_code%')\n  AND table_name IN ('CLARITY_EDG', 'PAT_ENC_DX', 'PROBLEM_LIST');",
    "description": "Search for ICD code columns in diagnosis tables",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 4
  },
  {
    "id": "02-03-diagnoses-and-problems-5",
    "originalQuery": "SELECT \n    CLM_DX as icd_code,\n    CLM_DX_QUAL as code_type,\n    COUNT(*) as occurrences\nFROM CLM_DX\nWHERE CLM_DX IS NOT NULL\nGROUP BY CLM_DX, CLM_DX_QUAL\nORDER BY occurrences DESC\nLIMIT 5;",
    "description": "Find ICD codes in the claims table",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 5
  },
  {
    "id": "02-03-diagnoses-and-problems-6",
    "originalQuery": "SELECT \n    p.PROBLEM_LIST_ID,\n    p.DESCRIPTION,\n    p.PROBLEM_STATUS_C_NAME,\n    p.DATE_OF_ENTRY,\n    p.RESOLVED_DATE,\n    p.CHRONIC_YN\nFROM PROBLEM_LIST p\nORDER BY p.DATE_OF_ENTRY;",
    "description": "Examine the problem list structure",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 6
  },
  {
    "id": "02-03-diagnoses-and-problems-7",
    "originalQuery": "-- Look for history table\nSELECT COUNT(*) as history_records\nFROM PROBLEM_LIST_HX;",
    "description": "Check for problem list history tracking",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 7
  },
  {
    "id": "02-03-diagnoses-and-problems-8",
    "originalQuery": "-- Check chronic diagnosis documentation\nSELECT \n    DX_CHRONIC_YN,\n    COUNT(*) as count,\n    CASE \n        WHEN DX_CHRONIC_YN = 'Y' THEN 'Marked as chronic'\n        WHEN DX_CHRONIC_YN = 'N' THEN 'Not chronic'\n        ELSE 'Not specified'\n    END as chronic_status\nFROM PAT_ENC_DX\nGROUP BY DX_CHRONIC_YN;",
    "description": "Find chronic diagnoses that might be on problem list",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 8
  },
  {
    "id": "02-03-diagnoses-and-problems-9",
    "originalQuery": "WITH dx_summary AS (\n    SELECT \n        PAT_ENC_CSN_ID,\n        COUNT(*) as diagnosis_count,\n        SUM(CASE WHEN PRIMARY_DX_YN = 'Y' THEN 1 ELSE 0 END) as primary_count,\n        SUM(CASE WHEN DX_CHRONIC_YN = 'Y' THEN 1 ELSE 0 END) as chronic_count\n    FROM PAT_ENC_DX\n    GROUP BY PAT_ENC_CSN_ID\n)\nSELECT \n    diagnosis_count,\n    COUNT(*) as encounters,\n    ROUND(100.0 * COUNT(*) / (SELECT COUNT(DISTINCT PAT_ENC_CSN_ID) FROM PAT_ENC_DX), 1) as percentage\nFROM dx_summary\nGROUP BY diagnosis_count\nORDER BY diagnosis_count;",
    "description": "Analyze diagnosis patterns across encounters",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 9
  },
  {
    "id": "02-03-diagnoses-and-problems-10",
    "originalQuery": "SELECT \n    e.PAT_ENC_CSN_ID,\n    p.CONTACT_DATE,\n    e.PRIMARY_DX_YN,\n    d.DX_NAME\nFROM PAT_ENC_DX e\nJOIN CLARITY_EDG d ON e.DX_ID = d.DX_ID\nJOIN PAT_ENC p ON e.PAT_ENC_CSN_ID = p.PAT_ENC_CSN_ID\nWHERE d.DX_NAME LIKE '%reflux%'\nORDER BY p.CONTACT_DATE DESC;",
    "description": "Find all GERD encounters",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 10
  },
  {
    "id": "02-03-diagnoses-and-problems-11",
    "originalQuery": "SELECT \n    p.CONTACT_DATE,\n    e.LINE,\n    e.PRIMARY_DX_YN,\n    d.DX_NAME,\n    e.DX_CHRONIC_YN\nFROM PAT_ENC_DX e\nJOIN CLARITY_EDG d ON e.DX_ID = d.DX_ID\nJOIN PAT_ENC p ON e.PAT_ENC_CSN_ID = p.PAT_ENC_CSN_ID\nWHERE p.PAT_ID = 'Z7004242'\nORDER BY p.PAT_ENC_DATE_REAL, e.LINE;",
    "description": "Create a timeline of diagnoses",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 11
  },
  {
    "id": "02-03-diagnoses-and-problems-12",
    "originalQuery": "-- In practice, you'd check both encounter diagnoses and problem list\n-- This example shows the encounter diagnosis approach\nSELECT DISTINCT\n    p.PAT_ID,\n    d.DX_NAME,\n    MAX(p.CONTACT_DATE) as most_recent_visit\nFROM PAT_ENC_DX e\nJOIN CLARITY_EDG d ON e.DX_ID = d.DX_ID\nJOIN PAT_ENC p ON e.PAT_ENC_CSN_ID = p.PAT_ENC_CSN_ID\nWHERE d.DX_NAME LIKE '%diabetes%'\nGROUP BY p.PAT_ID, d.DX_NAME;",
    "description": "Find diabetic patients (would check both sources)",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 12
  },
  {
    "id": "02-03-diagnoses-and-problems-13",
    "originalQuery": "-- Encounters with multiple primary diagnoses (should be none)\nWITH primary_count AS (\n    SELECT \n        PAT_ENC_CSN_ID,\n        SUM(CASE WHEN PRIMARY_DX_YN = 'Y' THEN 1 ELSE 0 END) as primary_dx_count\n    FROM PAT_ENC_DX\n    GROUP BY PAT_ENC_CSN_ID\n)\nSELECT \n    primary_dx_count,\n    COUNT(*) as encounters\nFROM primary_count\nGROUP BY primary_dx_count\nORDER BY primary_dx_count;",
    "description": "Check for data quality issues",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 13
  },
  {
    "id": "02-03-diagnoses-and-problems-14",
    "originalQuery": "-- Find potential hypertension cases by name\nSELECT DISTINCT\n    DX_ID,\n    DX_NAME\nFROM CLARITY_EDG\nWHERE UPPER(DX_NAME) LIKE '%HYPERTENSION%'\n   OR UPPER(DX_NAME) LIKE '%HIGH BLOOD PRESSURE%'\nORDER BY DX_NAME;",
    "description": "Use diagnosis names for approximate matching",
    "chapterId": "02-03-diagnoses-and-problems",
    "index": 14
  },
  {
    "id": "02-04-orders-and-results-0",
    "originalQuery": "SELECT \n    'Procedures (Labs, Imaging)' as order_type, \n    COUNT(*) as total_orders\nFROM ORDER_PROC\n\nUNION ALL\n\nSELECT \n    'Medications', \n    COUNT(*)\nFROM ORDER_MED\n\nORDER BY total_orders DESC;",
    "description": "Compare the two order types",
    "chapterId": "02-04-orders-and-results",
    "index": 0
  },
  {
    "id": "02-04-orders-and-results-1",
    "originalQuery": "SELECT \n    ORDER_PROC_ID,\n    PAT_ID,\n    PAT_ENC_CSN_ID,\n    ORDERING_DATE,\n    DESCRIPTION,\n    ORDER_STATUS_C_NAME,\n    ABNORMAL_YN\nFROM ORDER_PROC\nWHERE ORDER_STATUS_C_NAME = 'Completed'\nLIMIT 5;",
    "description": "Explore the procedural order structure",
    "chapterId": "02-04-orders-and-results",
    "index": 1
  },
  {
    "id": "02-04-orders-and-results-2",
    "originalQuery": "SELECT \n    ORDER_STATUS_C_NAME,\n    COUNT(*) as orders,\n    -- Check which have results\n    SUM(CASE WHEN ORDER_PROC_ID IN (SELECT DISTINCT ORDER_PROC_ID FROM ORDER_RESULTS) \n             THEN 1 ELSE 0 END) as has_results\nFROM ORDER_PROC\nGROUP BY ORDER_STATUS_C_NAME\nORDER BY orders DESC;",
    "description": "Analyze order status distribution",
    "chapterId": "02-04-orders-and-results",
    "index": 2
  },
  {
    "id": "02-04-orders-and-results-3",
    "originalQuery": "SELECT \n    o.DESCRIPTION as panel_name,\n    r.LINE,\n    r.COMPONENT_ID_NAME,\n    r.ORD_VALUE,\n    r.REFERENCE_LOW || '-' || r.REFERENCE_HIGH as reference_range,\n    r.REFERENCE_UNIT,\n    r.RESULT_FLAG_C_NAME\nFROM ORDER_PROC o\nJOIN ORDER_RESULTS r ON o.ORDER_PROC_ID = r.ORDER_PROC_ID\nWHERE o.ORDER_PROC_ID = 772179262\nORDER BY r.LINE;",
    "description": "Examine a complete metabolic panel with results",
    "chapterId": "02-04-orders-and-results",
    "index": 3
  },
  {
    "id": "02-04-orders-and-results-4",
    "originalQuery": "SELECT \n    COMPONENT_ID_NAME,\n    ORD_VALUE as text_value,\n    ORD_NUM_VALUE as numeric_value,\n    -- Check for non-numeric results\n    CASE \n        WHEN ORD_NUM_VALUE = 9999999 THEN 'Non-numeric result'\n        WHEN ORD_NUM_VALUE IS NULL THEN 'No numeric value'\n        ELSE 'Numeric result'\n    END as value_type\nFROM ORDER_RESULTS\nWHERE ORDER_PROC_ID IN (\n    SELECT ORDER_PROC_ID \n    FROM ORDER_RESULTS \n    WHERE ORD_VALUE NOT LIKE '%.%' \n      AND ORD_VALUE NOT GLOB '[0-9]*'\n    LIMIT 5\n);",
    "description": "Compare text vs numeric result storage",
    "chapterId": "02-04-orders-and-results",
    "index": 4
  },
  {
    "id": "02-04-orders-and-results-5",
    "originalQuery": "-- First, check order-level summary\nSELECT \n    o.ORDER_PROC_ID,\n    o.DESCRIPTION,\n    o.ABNORMAL_YN as order_abnormal,\n    COUNT(r.LINE) as total_components,\n    SUM(CASE WHEN r.RESULT_FLAG_C_NAME != '(NONE)' AND r.RESULT_FLAG_C_NAME IS NOT NULL \n             THEN 1 ELSE 0 END) as abnormal_components\nFROM ORDER_PROC o\nJOIN ORDER_RESULTS r ON o.ORDER_PROC_ID = r.ORDER_PROC_ID\nWHERE o.ABNORMAL_YN = 'Y'\nGROUP BY o.ORDER_PROC_ID\nLIMIT 5;",
    "description": "Understand abnormal result hierarchy",
    "chapterId": "02-04-orders-and-results",
    "index": 5
  },
  {
    "id": "02-04-orders-and-results-6",
    "originalQuery": "SELECT \n    om.ORDER_MED_ID,\n    om.PAT_ENC_CSN_ID,\n    om.MEDICATION_ID,\n    cm.GENERIC_NAME,\n    om.ORDER_STATUS_C_NAME,\n    om.ORDERING_MODE_C_NAME\nFROM ORDER_MED om\nJOIN CLARITY_MEDICATION cm ON om.MEDICATION_ID = cm.MEDICATION_ID\nORDER BY om.ORDERING_DATE DESC;",
    "description": "Explore medication order structure",
    "chapterId": "02-04-orders-and-results",
    "index": 6
  },
  {
    "id": "02-04-orders-and-results-7",
    "originalQuery": "SELECT \n    MEDICATION_ID,\n    GENERIC_NAME,\n    -- Count how many times each medication was ordered\n    (SELECT COUNT(*) FROM ORDER_MED om WHERE om.MEDICATION_ID = cm.MEDICATION_ID) as times_ordered\nFROM CLARITY_MEDICATION cm\nWHERE MEDICATION_ID IN (SELECT DISTINCT MEDICATION_ID FROM ORDER_MED)\nORDER BY times_ordered DESC;",
    "description": "Explore the medication formulary",
    "chapterId": "02-04-orders-and-results",
    "index": 7
  },
  {
    "id": "02-04-orders-and-results-8",
    "originalQuery": "SELECT \n    o.ORDER_PROC_ID,\n    o.DESCRIPTION as test_ordered,\n    p.CONTACT_DATE,\n    p.DEPARTMENT_ID,\n    p.VISIT_PROV_ID,\n    -- Get primary diagnosis for context\n    d.DX_NAME as primary_diagnosis\nFROM ORDER_PROC o\nJOIN PAT_ENC p ON o.PAT_ENC_CSN_ID = p.PAT_ENC_CSN_ID\nLEFT JOIN PAT_ENC_DX dx ON p.PAT_ENC_CSN_ID = dx.PAT_ENC_CSN_ID AND dx.PRIMARY_DX_YN = 'Y'\nLEFT JOIN CLARITY_EDG d ON dx.DX_ID = d.DX_ID\nWHERE o.ORDER_STATUS_C_NAME = 'Completed'\nLIMIT 5;",
    "description": "Connect orders to their clinical context",
    "chapterId": "02-04-orders-and-results",
    "index": 8
  },
  {
    "id": "02-04-orders-and-results-9",
    "originalQuery": "-- Check ORDER_PROC provider fields\nSELECT \n    COUNT(*) as total_orders,\n    COUNT(AUTHRZING_PROV_ID) as has_authorizing,\n    COUNT(REFERRING_PROV_ID) as has_referring,\n    COUNT(BILLING_PROV_ID) as has_billing\nFROM ORDER_PROC;",
    "description": "Analyze provider patterns in orders",
    "chapterId": "02-04-orders-and-results",
    "index": 9
  },
  {
    "id": "02-04-orders-and-results-10",
    "originalQuery": "WITH turnaround AS (\n    SELECT \n        o.ORDER_PROC_ID,\n        o.DESCRIPTION,\n        o.ORDERING_DATE,\n        MIN(r.RESULT_DATE) as first_result,\n        -- Calculate days between order and result\n        ROUND(julianday(MIN(r.RESULT_DATE)) - julianday(o.ORDERING_DATE), 1) as days_to_result\n    FROM ORDER_PROC o\n    JOIN ORDER_RESULTS r ON o.ORDER_PROC_ID = r.ORDER_PROC_ID\n    WHERE o.ORDERING_DATE IS NOT NULL \n      AND r.RESULT_DATE IS NOT NULL\n    GROUP BY o.ORDER_PROC_ID\n)\nSELECT \n    CASE \n        WHEN days_to_result < 1 THEN 'Same day'\n        WHEN days_to_result < 2 THEN '1 day'\n        WHEN days_to_result < 7 THEN '2-6 days'\n        ELSE '7+ days'\n    END as turnaround_category,\n    COUNT(*) as orders\nFROM turnaround\nGROUP BY turnaround_category\nORDER BY MIN(days_to_result);",
    "description": "Analyze order to result turnaround times",
    "chapterId": "02-04-orders-and-results",
    "index": 10
  },
  {
    "id": "02-04-orders-and-results-11",
    "originalQuery": "SELECT name \nFROM sqlite_master \nWHERE type = 'table' \n  AND name LIKE '%MAR%';",
    "description": "Search for MAR tables",
    "chapterId": "02-04-orders-and-results",
    "index": 11
  },
  {
    "id": "02-04-orders-and-results-12",
    "originalQuery": "WITH order_summary AS (\n    SELECT \n        o.ORDER_PROC_ID,\n        o.DESCRIPTION,\n        o.ORDERING_DATE,\n        o.ORDER_STATUS_C_NAME,\n        o.ABNORMAL_YN,\n        COUNT(r.LINE) as result_count,\n        -- Aggregate result summaries\n        GROUP_CONCAT(\n            r.COMPONENT_ID_NAME || ': ' || r.ORD_VALUE || ' ' || \n            COALESCE(r.REFERENCE_UNIT, '') ||\n            CASE WHEN r.RESULT_FLAG_C_NAME != '(NONE)' \n                 THEN ' [' || r.RESULT_FLAG_C_NAME || ']' \n                 ELSE '' \n            END, \n            '; '\n        ) as results_summary\n    FROM ORDER_PROC o\n    LEFT JOIN ORDER_RESULTS r ON o.ORDER_PROC_ID = r.ORDER_PROC_ID\n    WHERE o.ORDER_STATUS_C_NAME = 'Completed'\n    GROUP BY o.ORDER_PROC_ID\n)\nSELECT * FROM order_summary\nWHERE result_count > 0\nLIMIT 3;",
    "description": "Create a complete order-to-result summary",
    "chapterId": "02-04-orders-and-results",
    "index": 12
  },
  {
    "id": "02-04-orders-and-results-13",
    "originalQuery": "-- Completed orders that lack results\nSELECT \n    o.ORDER_PROC_ID,\n    o.DESCRIPTION,\n    o.ORDERING_DATE,\n    o.ORDER_STATUS_C_NAME\nFROM ORDER_PROC o\nLEFT JOIN ORDER_RESULTS r ON o.ORDER_PROC_ID = r.ORDER_PROC_ID\nWHERE o.ORDER_STATUS_C_NAME = 'Completed'\n  AND r.ORDER_PROC_ID IS NULL;",
    "description": "Check for orders without results",
    "chapterId": "02-04-orders-and-results",
    "index": 13
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-0",
    "originalQuery": "SELECT \n    'Medication Orders' as data_type, COUNT(*) as records FROM ORDER_MED\nUNION ALL\nSELECT 'Allergies', COUNT(*) FROM PAT_ALLERGIES\nUNION ALL\nSELECT 'Immunizations', COUNT(*) FROM PAT_IMMUNIZATIONS\nORDER BY records DESC;",
    "description": "Overview of safety-critical data volumes",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 0
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-1",
    "originalQuery": "SELECT \n    om.ORDER_MED_ID,\n    cm.GENERIC_NAME,\n    om.ORDERING_DATE,\n    om.ORDER_END_TIME,\n    om.DISCON_TIME,\n    -- Calculate if discontinued early\n    CASE \n        WHEN om.DISCON_TIME IS NOT NULL \n         AND om.DISCON_TIME < om.ORDER_END_TIME\n        THEN 'Discontinued Early'\n        WHEN om.DISCON_TIME IS NOT NULL\n        THEN 'Completed as Ordered'\n        ELSE 'Active/Unknown'\n    END as medication_status\nFROM ORDER_MED om\nJOIN CLARITY_MEDICATION cm ON om.MEDICATION_ID = cm.MEDICATION_ID\nORDER BY om.ORDERING_DATE;",
    "description": "Analyze medication lifecycle with discontinuation",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 1
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-2",
    "originalQuery": "-- Check for any MAR-related tables\nSELECT name \nFROM sqlite_master \nWHERE type = 'table' \n  AND (name LIKE '%MAR%' OR name LIKE '%ADMIN%')\n  AND name LIKE '%MED%';",
    "description": "Search for administration data",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 2
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-3",
    "originalQuery": "-- Patient-to-allergy linking\nSELECT \n    pa.PAT_ID,\n    pa.LINE,\n    pa.ALLERGY_RECORD_ID,\n    a.ALLERGEN_ID_ALLERGEN_NAME,\n    a.SEVERITY_C_NAME,\n    a.ALRGY_STATUS_C_NAME\nFROM PAT_ALLERGIES pa\nJOIN ALLERGY a ON a.ALLERGY_ID = pa.ALLERGY_RECORD_ID\nWHERE pa.PAT_ID = 'Z7004242'\nORDER BY pa.LINE;",
    "description": "Explore the allergy data model",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 3
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-4",
    "originalQuery": "SELECT \n    a.ALLERGEN_ID_ALLERGEN_NAME as allergen,\n    a.SEVERITY_C_NAME as severity,\n    ar.LINE,\n    ar.REACTION_C_NAME\nFROM ALLERGY a\nJOIN ALLERGY_REACTIONS ar ON a.ALLERGY_ID = ar.ALLERGY_ID\nWHERE a.ALLERGY_ID IN (\n    SELECT ALLERGY_RECORD_ID \n    FROM PAT_ALLERGIES \n    WHERE PAT_ID = 'Z7004242'\n)\nORDER BY a.ALLERGY_ID, ar.LINE;",
    "description": "View allergy reactions detail",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 4
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-5",
    "originalQuery": "SELECT \n    ALRGY_STATUS_C_NAME,\n    COUNT(*) as count,\n    GROUP_CONCAT(ALLERGEN_ID_ALLERGEN_NAME, ', ') as examples\nFROM ALLERGY\nGROUP BY ALRGY_STATUS_C_NAME;",
    "description": "Analyze allergy statuses",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 5
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-6",
    "originalQuery": "-- Look for No Known Allergies entries and show actual allergens\nSELECT \n    ALLERGEN_ID_ALLERGEN_NAME,\n    ALRGY_STATUS_C_NAME,\n    COUNT(*) as patient_count,\n    CASE \n        WHEN UPPER(ALLERGEN_ID_ALLERGEN_NAME) LIKE '%NO%KNOWN%' \n          OR UPPER(ALLERGEN_ID_ALLERGEN_NAME) LIKE '%NKA%' \n        THEN 'NKA Entry'\n        ELSE 'Specific Allergen'\n    END as entry_type\nFROM ALLERGY\nGROUP BY ALLERGEN_ID_ALLERGEN_NAME, ALRGY_STATUS_C_NAME\nORDER BY patient_count DESC;",
    "description": "Search for NKA documentation",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 6
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-7",
    "originalQuery": "SELECT \n    pi.PAT_ID,\n    pi.LINE,\n    i.IMMUNZATN_ID_NAME,\n    i.IMMUNE_DATE,\n    i.DOSE,\n    i.ROUTE_C_NAME,\n    i.IMMNZTN_STATUS_C_NAME\nFROM PAT_IMMUNIZATIONS pi\nJOIN IMMUNE i ON pi.IMMUNE_ID = i.IMMUNE_ID\nWHERE pi.PAT_ID = 'Z7004242'\nORDER BY i.IMMUNE_DATE DESC;",
    "description": "Explore immunization records",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 7
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-8",
    "originalQuery": "SELECT \n    i.IMMNZTN_STATUS_C_NAME,\n    COUNT(*) as count,\n    GROUP_CONCAT(DISTINCT i.IMMUNZATN_ID_NAME) as vaccines\nFROM IMMUNE i\nGROUP BY i.IMMNZTN_STATUS_C_NAME;",
    "description": "Analyze immunization sources",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 8
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-9",
    "originalQuery": "SELECT \n    IMMUNZATN_ID_NAME as vaccine,\n    IMMUNE_DATE,\n    MFG_C_NAME as manufacturer,\n    LOT as lot_number,\n    EXP_DATE as expiration,\n    DOSE,\n    ROUTE_C_NAME as route,\n    SITE_C_NAME as site\nFROM IMMUNE\nWHERE LOT IS NOT NULL\nORDER BY IMMUNE_DATE DESC\nLIMIT 5;",
    "description": "View complete vaccine administration details",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 9
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-10",
    "originalQuery": "-- Find patients with medication orders who have allergies\n-- (In production, you'd check for specific drug-allergy interactions)\nWITH patient_allergies AS (\n    SELECT DISTINCT \n        pa.PAT_ID,\n        COUNT(DISTINCT a.ALLERGEN_ID) as allergy_count\n    FROM PAT_ALLERGIES pa\n    JOIN ALLERGY a ON pa.ALLERGY_RECORD_ID = a.ALLERGY_ID\n    WHERE a.ALRGY_STATUS_C_NAME = 'Active'\n    GROUP BY pa.PAT_ID\n),\npatient_meds AS (\n    SELECT DISTINCT\n        om.PAT_ID,\n        COUNT(DISTINCT om.MEDICATION_ID) as med_count\n    FROM ORDER_MED om\n    WHERE om.ORDER_STATUS_C_NAME = 'Sent'\n    GROUP BY om.PAT_ID\n)\nSELECT \n    pm.PAT_ID,\n    pm.med_count as active_medications,\n    COALESCE(pa.allergy_count, 0) as active_allergies\nFROM patient_meds pm\nLEFT JOIN patient_allergies pa ON pm.PAT_ID = pa.PAT_ID;",
    "description": "Check for potential medication-allergy conflicts",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 10
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-11",
    "originalQuery": "WITH vaccine_doses AS (\n    SELECT \n        IMMUNZATN_ID_NAME,\n        MAX(CAST(DOSE AS INTEGER)) as max_dose,\n        COUNT(*) as total_records\n    FROM IMMUNE\n    WHERE CAST(DOSE AS TEXT) GLOB '[0-9]*'  -- Only numeric doses\n    GROUP BY IMMUNZATN_ID_NAME\n)\nSELECT \n    IMMUNZATN_ID_NAME as vaccine,\n    max_dose as highest_dose_given,\n    total_records,\n    CASE \n        WHEN max_dose >= 2 THEN 'Multi-dose series'\n        ELSE 'Single dose'\n    END as series_type\nFROM vaccine_doses\nORDER BY max_dose DESC;",
    "description": "Analyze vaccine series completion",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 11
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-12",
    "originalQuery": "-- Combine medications and allergy updates in chronological order\nSELECT \n    'Medication Started' as event_type,\n    ORDERING_DATE as event_date,\n    GENERIC_NAME as description\nFROM ORDER_MED om\nJOIN CLARITY_MEDICATION cm ON om.MEDICATION_ID = cm.MEDICATION_ID\nWHERE om.PAT_ID = 'Z7004242'\n\nUNION ALL\n\nSELECT \n    'Allergy Noted' as event_type,\n    a.DATE_NOTED as event_date,\n    a.ALLERGEN_ID_ALLERGEN_NAME as description\nFROM ALLERGY a\nJOIN PAT_ALLERGIES pa ON a.ALLERGY_ID = pa.ALLERGY_RECORD_ID\nWHERE pa.PAT_ID = 'Z7004242'\n\nORDER BY event_date DESC;",
    "description": "Create a patient safety timeline",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 12
  },
  {
    "id": "02-05-medications-allergies-and-immunizations-13",
    "originalQuery": "WITH safety_summary AS (\n    SELECT \n        p.PAT_ID,\n        p.PAT_NAME,\n        -- Count active medications\n        (SELECT COUNT(*) FROM ORDER_MED om \n         WHERE om.PAT_ID = p.PAT_ID \n           AND om.ORDER_STATUS_C_NAME = 'Sent'\n           AND om.DISCON_TIME IS NULL) as active_meds,\n        -- Count active allergies\n        (SELECT COUNT(DISTINCT pa.ALLERGY_RECORD_ID) \n         FROM PAT_ALLERGIES pa\n         JOIN ALLERGY a ON pa.ALLERGY_RECORD_ID = a.ALLERGY_ID\n         WHERE pa.PAT_ID = p.PAT_ID\n           AND a.ALRGY_STATUS_C_NAME = 'Active') as active_allergies,\n        -- Count immunizations\n        (SELECT COUNT(*) FROM PAT_IMMUNIZATIONS pi\n         WHERE pi.PAT_ID = p.PAT_ID) as total_immunizations\n    FROM PATIENT p\n)\nSELECT * FROM safety_summary;",
    "description": "Create a comprehensive patient safety summary",
    "chapterId": "02-05-medications-allergies-and-immunizations",
    "index": 13
  }
]